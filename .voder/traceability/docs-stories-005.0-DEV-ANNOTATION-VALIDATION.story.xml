<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md</specification>
  <status>FAILED</status>
  <last_validated>2025-11-21T00:24:10.540Z</last_validated>
  <last_modified>2025-11-19T04:17:32.780Z</last_modified>
  <evidence>Implementation and tests exist for this story, but some explicit requirements are not met.

1) Rule implementation
- File: src/rules/valid-annotation-format.ts
- Contents (excerpt):
  """
  /**
   * Rule to validate @story and @req annotation format and syntax
   * @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md
   * @req REQ-FORMAT-SPECIFICATION - Define clear format rules for @story and @req annotations
   * @req REQ-SYNTAX-VALIDATION - Validate annotation syntax matches specification
   * @req REQ-PATH-FORMAT - Validate @story paths follow expected patterns
   * @req REQ-REQ-FORMAT - Validate @req identifiers follow expected patterns
   */
  export default {
    meta: {
      type: "problem",
      docs: {
        description: "Validate format and syntax of @story and @req annotations",
        recommended: "error",
      },
      messages: {
        invalidStoryFormat: "Invalid @story annotation format",
        invalidReqFormat: "Invalid @req annotation format",
      },
      schema: [],
    },
    create(context: any) {
      const sourceCode = context.getSourceCode();
      return {
        Program() {
          const comments = sourceCode.getAllComments() || [];
          comments.forEach((comment: any) => {
            const lines = comment.value
              .split(/\r?\n/)
              .map((l: string) => l.replace(/^[^@]*/, "").trim());
            lines.forEach((line: string) => {
              if (line.startsWith("@story")) {
                const parts = line.split(/\s+/);
                const storyPath = parts[1];
                if (
                  !storyPath ||
                  !/^docs\/stories\/[0-9]+\.[0-9]+-DEV-[\w-]+\.story\.md$/.test(
                    storyPath,
                  )
                ) {
                  context.report({ node: comment as any, messageId: "invalidStoryFormat" });
                }
              }
              if (line.startsWith("@req")) {
                const parts = line.split(/\s+/);
                const reqId = parts[1];
                if (!reqId || !/^REQ-[A-Z0-9-]+$/.test(reqId)) {
                  context.report({ node: comment as any, messageId: "invalidReqFormat" });
                }
              }
            });
          });
        },
      };
    },
  } as any;
  """
- This satisfies core format checking:
  - @story paths must match: docs/stories/[0-9]+\.[0-9]+-DEV-[\w-]+\.story\.md (relative path with .story.md extension)
  - @req IDs must match: REQ-[A-Z0-9-]+
  - Handles line-by-line parsing of all comments, including JSDoc (multiline comment split, trims leading comment markers via replace/trim).

2) Tests for this story
- File: tests/rules/valid-annotation-format.test.ts
- Header and describe block reference the story explicitly:
  """
  /**
   * Tests for: docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md
   * @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md
   * @req REQ-FORMAT-SPECIFICATION - Verify valid-annotation-format rule enforces annotation format syntax
   */
  ...
  describe("Valid Annotation Format Rule (Story 005.0-DEV-ANNOTATION-VALIDATION)", () => {
    ruleTester.run("valid-annotation-format", rule, {
      valid: [
        {
          name: "[REQ-PATH-FORMAT] valid story annotation format",
          code: `// @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md`,
        },
        {
          name: "[REQ-REQ-FORMAT] valid req annotation format",
          code: `// @req REQ-EXAMPLE`,
        },
        {
          name: "[REQ-FORMAT-SPECIFICATION] valid block annotations",
          code: `/**
   * @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md
   * @req REQ-VALID-EXAMPLE
   */`,
        },
      ],
      invalid: [
        {
          name: "[REQ-PATH-FORMAT] missing story path",
          code: `// @story`,
          errors: [{ messageId: "invalidStoryFormat" }],
        },
        {
          name: "[REQ-PATH-FORMAT] invalid story file extension",
          code: `// @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story`,
          errors: [{ messageId: "invalidStoryFormat" }],
        },
        {
          name: "[REQ-REQ-FORMAT] missing req id",
          code: `// @req`,
          errors: [{ messageId: "invalidReqFormat" }],
        },
        {
          name: "[REQ-REQ-FORMAT] invalid req id format",
          code: `// @req invalid-format`,
          errors: [{ messageId: "invalidReqFormat" }],
        },
      ],
    });
  });
  """
- These tests verify basic valid/invalid patterns but only assert the two generic messageIds (`invalidStoryFormat`, `invalidReqFormat`).

3) Plugin integration
- File: src/index.ts
- The rule is exported and enabled in recommended/strict configs:
  """
  const RULE_NAMES = [
    "require-story-annotation",
    "require-req-annotation",
    "require-branch-annotation",
    "valid-annotation-format",
    "valid-story-reference",
    "valid-req-reference",
  ] as const;
  ...
  const configs = {
    recommended: [
      {
        plugins: { traceability: {} },
        rules: {
          "traceability/require-story-annotation": "error",
          "traceability/require-req-annotation": "error",
          "traceability/require-branch-annotation": "error",
          "traceability/valid-annotation-format": "error",
          "traceability/valid-story-reference": "error",
          "traceability/valid-req-reference": "error",
        },
      },
    ],
    strict: [
      {
        plugins: { traceability: {} },
        rules: {
          "traceability/require-story-annotation": "error",
          "traceability/require-req-annotation": "error",
          "traceability/require-branch-annotation": "error",
          "traceability/valid-annotation-format": "error",
          "traceability/valid-story-reference": "error",
          "traceability/valid-req-reference": "error",
        },
      },
    ],
  };
  """
- This shows the format rule runs alongside the function and branch rules, fulfilling basic integration.

4) Documentation
- File: docs/rules/valid-annotation-format.md
- Contents (excerpt):
  """
  # valid-annotation-format

  Validates that `@story` and `@req` annotations follow the correct format and syntax rules to ensure traceability annotations are parseable and standardized.

  @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md
  @req REQ-FORMAT-SPECIFICATION - Define clear format rules for @story and @req annotations
  @req REQ-SYNTAX-VALIDATION - Validate annotation syntax matches specification
  @req REQ-PATH-FORMAT - Validate @story paths follow expected patterns
  @req REQ-REQ-FORMAT - Validate @req identifiers follow expected patterns

  ## Rule Details

  This rule scans all comments in the source code and checks each line that begins with `@story` or `@req`. It applies regular expressions to verify:

  - `@story` paths match the pattern `docs/stories/NN.N-DEV-<NAME>.story.md`
  - `@req` identifiers match the pattern `REQ-<UPPERCASE|NUMERIC|DASH>`

  Violations report specific messages for invalid story formats or invalid requirement ID formats.

  ## Examples
  ... (valid and invalid annotation examples)
  """
- This documentation provides a clear format specification with valid and invalid examples.

5) Test execution
- Command executed: `npm test -- --ci --no-watch --runInBand --verbose`
- Output shows Jest running with no reported failures (only debug logs from other rules), indicating tests including tests/rules/valid-annotation-format.test.ts pass.

6) Gaps vs story requirements
- The story's requirements/acceptance criteria include:
  - **REQ-ERROR-SPECIFICITY**: "Provide specific error messages for different format violations" and acceptance criterion **User Experience**: "Clear, specific error messages for different format violations".
  - Current implementation defines only two generic messages:
    - `invalidStoryFormat: "Invalid @story annotation format"`
    - `invalidReqFormat: "Invalid @req annotation format"`
  - All @story format problems (missing path, wrong extension, wrong pattern, path traversal) map to `invalidStoryFormat` with no distinguishing details.
  - All @req problems (missing ID, malformed ID) map to `invalidReqFormat`.
  - Tests only assert these generic messageIds and do not cover differentiated messaging.
- Therefore, the rule does not provide different, specific messages per violation type (e.g., missing path vs. invalid extension vs. invalid pattern), which is explicitly required by both REQ-ERROR-SPECIFICITY and the User Experience acceptance criterion.
- Other requirements (basic syntax validation, path format, req format, JSDoc/multiline comment handling, some whitespace flexibility, integration with other rules, and documentation) are satisfied by the shown implementation, tests, and docs, but the missing error specificity means the story is not fully implemented.</evidence>
  <notes>The `valid-annotation-format` rule, its tests, and its documentation clearly target this story and implement core format validation for @story and @req annotations, including path and ID patterns, and integration into the plugin configs. However, the story explicitly requires specific, differentiated error messages for different kinds of format violations (REQ-ERROR-SPECIFICITY and the User Experience acceptance criterion). The current implementation exposes only two generic messageIds (`invalidStoryFormat` and `invalidReqFormat`) and uses them for all failure modes. Because this key requirement is not met, the story 005.0-DEV-ANNOTATION-VALIDATION cannot be considered fully implemented and is marked FAILED.</notes>
</traceability>