<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md</specification>
  <status>FAILED</status>
  <last_validated>2025-11-21T01:24:38.107Z</last_validated>
  <last_modified>2025-11-19T04:17:32.780Z</last_modified>
  <evidence>Implementation and wiring for this story do exist:

1) Story-specific rule implementation
- File: src/rules/valid-annotation-format.ts
  """
  /**
   * Rule to validate @story and @req annotation format and syntax
   * @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md
   * @req REQ-FORMAT-SPECIFICATION - Define clear format rules for @story and @req annotations
   * @req REQ-SYNTAX-VALIDATION - Validate annotation syntax matches specification
   * @req REQ-PATH-FORMAT - Validate @story paths follow expected patterns
   * @req REQ-REQ-FORMAT - Validate @req identifiers follow expected patterns
   */
  export default {
    meta: {
      type: "problem",
      docs: {
        description: "Validate format and syntax of @story and @req annotations",
        recommended: "error",
      },
      messages: {
        invalidStoryFormat: "Invalid @story annotation format",
        invalidReqFormat: "Invalid @req annotation format",
      },
      schema: [],
    },
    create(context: any) {
      const sourceCode = context.getSourceCode();
      return {
        Program() {
          const comments = sourceCode.getAllComments() || [];
          comments.forEach((comment: any) => {
            const lines = comment.value
              .split(/\r?\n/)
              .map((l: string) => l.replace(/^[^@]*/, "").trim());
            lines.forEach((line: string) => {
              if (line.startsWith("@story")) {
                const parts = line.split(/\s+/);
                const storyPath = parts[1];
                if (
                  !storyPath ||
                  !/^docs\/stories\/[0-9]+\.[0-9]+-DEV-[\w-]+\.story\.md$/.test(storyPath)
                ) {
                  context.report({ node: comment as any, messageId: "invalidStoryFormat" });
                }
              }
              if (line.startsWith("@req")) {
                const parts = line.split(/\s+/);
                const reqId = parts[1];
                if (!reqId || !/^REQ-[A-Z0-9-]+$/.test(reqId)) {
                  context.report({ node: comment as any, messageId: "invalidReqFormat" });
                }
              }
            });
          });
        },
      };
    },
  } as any;
  """
- This directly addresses:
  - REQ-FORMAT-SPECIFICATION
  - REQ-SYNTAX-VALIDATION
  - REQ-PATH-FORMAT (regex for docs/stories/... .story.md)
  - REQ-REQ-FORMAT (REQ-[A-Z0-9-]+ pattern)

2) Rule is integrated into plugin exports and configs
- File: src/index.ts
  - RULE_NAMES includes "valid-annotation-format":
    const RULE_NAMES = [
      "require-story-annotation",
      "require-req-annotation",
      "require-branch-annotation",
      "valid-annotation-format",
      "valid-story-reference",
      "valid-req-reference",
    ] as const;
  - Both recommended and strict configs enable it:
    "traceability/valid-annotation-format": "error",
- This satisfies the Integration acceptance criterion (works alongside function/branch rules in plugin configs).

3) Story-specific tests exist and pass
- File: tests/rules/valid-annotation-format.test.ts
  """
  /**
   * Tests for: docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md
   * @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md
   * @req REQ-FORMAT-SPECIFICATION - Verify valid-annotation-format rule enforces annotation format syntax
   */
  describe("Valid Annotation Format Rule (Story 005.0-DEV-ANNOTATION-VALIDATION)", () => {
    ruleTester.run("valid-annotation-format", rule, {
      valid: [
        {
          name: "[REQ-PATH-FORMAT] valid story annotation format",
          code: `// @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md`,
        },
        {
          name: "[REQ-REQ-FORMAT] valid req annotation format",
          code: `// @req REQ-EXAMPLE`,
        },
        {
          name: "[REQ-FORMAT-SPECIFICATION] valid block annotations",
          code: `/**
   * @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md
   * @req REQ-VALID-EXAMPLE
   */`,
        },
      ],
      invalid: [
        {
          name: "[REQ-PATH-FORMAT] missing story path",
          code: `// @story`,
          errors: [{ messageId: "invalidStoryFormat" }],
        },
        {
          name: "[REQ-PATH-FORMAT] invalid story file extension",
          code: `// @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story`,
          errors: [{ messageId: "invalidStoryFormat" }],
        },
        {
          name: "[REQ-REQ-FORMAT] missing req id",
          code: `// @req`,
          errors: [{ messageId: "invalidReqFormat" }],
        },
        {
          name: "[REQ-REQ-FORMAT] invalid req id format",
          code: `// @req invalid-format`,
          errors: [{ messageId: "invalidReqFormat" }],
        },
      ],
    });
  });
  """
- These tests directly exercise valid and invalid annotation formats and confirm that the rule reports using messageIds invalidStoryFormat/invalidReqFormat.
- The overall Jest test run (npm test -- --runInBand --verbose) completes without failures, indicating this rule’s tests pass.

4) Why the story is not fully satisfied
- Missing REQ-MULTILINE-SUPPORT:
  - Story requires: "Handle annotations split across multiple lines".
  - Implementation logic reads each line independently and expects the value (path or req ID) to be on the same line as the tag:
    - For @story: const storyPath = parts[1]; // same line
    - For @req: const reqId = parts[1];       // same line
  - There is no code to join or continue to the next line to read a split path/ID, nor any tests for such patterns.
- Missing REQ-ERROR-SPECIFICITY and full User Experience acceptance criterion:
  - Story requires "Clear, specific error messages for different format violations" and REQ-ERROR-SPECIFICITY.
  - Implementation defines only two generic messages:
    messages: {
      invalidStoryFormat: "Invalid @story annotation format",
      invalidReqFormat: "Invalid @req annotation format",
    }
  - All @story issues (missing path, wrong extension, path traversal, etc.) map to invalidStoryFormat; all @req issues map to invalidReqFormat. There is no differentiation per specific violation type.
  - Tests likewise only assert these generic messageIds; they do not cover distinct error messages for distinct failure modes.
- Partial coverage of flexible parsing and malformed comment handling:
  - The rule strips leading non-@ characters to handle comment prefixes, which is a step toward "flexible parsing" and basic malformed structure handling.
  - However, it does not accommodate multi-line value continuation, nor does it provide different handling/messages for the various malformed examples in the story (e.g., path traversal vs missing extension vs missing identifier).

Given that REQ-MULTILINE-SUPPORT and REQ-ERROR-SPECIFICITY are not implemented or tested, and the acceptance criteria for clear, specific error messages and robust edge-case handling are only partially met, the story cannot be considered fully implemented.</evidence>
  <notes>The project includes a dedicated ESLint rule (valid-annotation-format) and tests that validate basic @story and @req annotation syntax, file path pattern, and req ID pattern, and this rule is wired into the plugin’s recommended/strict configs. This satisfies several core requirements of the story (format specification, syntax validation, path/id format checks, and basic integration). However, key story requirements remain unimplemented: multi-line annotations are not supported (values must be on the same line as @story/@req), and error messages are generic rather than specific to each violation type, contrary to REQ-MULTILINE-SUPPORT, REQ-ERROR-SPECIFICITY, and the User Experience acceptance criterion. Therefore, the story is only partially implemented and must be marked as FAILED for this assessment.</notes>
</traceability>