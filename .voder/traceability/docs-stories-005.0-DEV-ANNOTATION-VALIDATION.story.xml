<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md</specification>
  <status>PASSED</status>
  <last_validated>2025-11-21T05:01:49.483Z</last_validated>
  <last_modified>2025-11-21T04:06:15.904Z</last_modified>
  <evidence>Implementation:
- Core rule implementation is in src/rules/valid-annotation-format.ts. The file header explicitly links to this story and all listed requirements: `@story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md` plus `@req` tags for REQ-FORMAT-SPECIFICATION, REQ-SYNTAX-VALIDATION, REQ-PATH-FORMAT, REQ-REQ-FORMAT, REQ-MULTILINE-SUPPORT, REQ-FLEXIBLE-PARSING, and REQ-ERROR-SPECIFICITY.
- The rule defines utility functions that directly implement the required behaviors:
  - normalizeCommentLine(rawLine): trims whitespace, strips leading `*`, and robustly locates `@story`/`@req` tokens even with JSDoc-style formatting and extra spacing, satisfying REQ-FLEXIBLE-PARSING and supporting various comment styles.
  - collapseAnnotationValue(value): removes all internal whitespace so multi-line annotations become a single logical value, satisfying REQ-MULTILINE-SUPPORT.
  - buildStoryErrorMessage(kind, value) and buildReqErrorMessage(kind, value): generate precise, user-facing messages for missing vs invalid values, embedding example formats (e.g., “Expected a path like "docs/stories/005.0-DEV-EXAMPLE.story.md"” and “Expected an identifier like "REQ-EXAMPLE"”), satisfying REQ-ERROR-SPECIFICITY.
  - validateStoryAnnotation(context, comment, rawValue): trims and collapses the value, reports `invalidStoryFormat` with a specific message when missing, and validates the final value against `^docs\/stories\/[0-9]+\.[0-9]+-DEV-[\w-]+\.story\.md$`, enforcing the docs/stories-relative path, numeric prefix, DEV marker, name slug, and .story.md suffix and implicitly disallowing `../` traversal. This satisfies REQ-PATH-FORMAT and contributes to REQ-SYNTAX-VALIDATION.
  - validateReqAnnotation(context, comment, rawValue): trims and collapses the value, reports `invalidReqFormat` with a specific message when missing, and validates the final value against `^REQ-[A-Z0-9-]+$`, enforcing REQ-* with only uppercase letters, digits, and dashes, satisfying REQ-REQ-FORMAT and REQ-SYNTAX-VALIDATION.
  - processComment(context, comment): walks all lines in a comment, using normalizeCommentLine and a PendingAnnotation state to detect `@story`/`@req` lines, collect continuation lines across multiple comment lines, and finally call validateStoryAnnotation/validateReqAnnotation. It gracefully ignores empty or irrelevant lines and never throws on malformed comments, satisfying REQ-MULTILINE-SUPPORT, REQ-FLEXIBLE-PARSING, and Error Handling AC.
- The rule is exported as a standard ESLint RuleModule with:
  - meta.type = "problem"; docs.description = "Validate format and syntax of @story and @req annotations"; recommended = "error"; messages.invalidStoryFormat and messages.invalidReqFormat using `{{details}}`; schema = []. This follows ESLint best practices (Quality Standards AC).
  - create(context) obtains sourceCode via context.getSourceCode() and, in the Program visitor, iterates over all comments from sourceCode.getAllComments(), passing each to processComment. This integrates format validation with whichever annotations are discovered by the annotation-detection rules (Integration AC).

Plugin Integration:
- src/index.ts registers this rule:
  - RULE_NAMES includes "valid-annotation-format" alongside other core rules: require-story-annotation, require-req-annotation, require-branch-annotation, valid-story-reference, valid-req-reference.
  - The dynamic loader requires each ./rules/${name} and exposes it via the exported rules map.
  - The rule is configured in both recommended and strict configs: `"traceability/valid-annotation-format": "warn"`. This ensures it runs whenever consumers use the plugin’s recommended or strict presets and operates on annotations detected by other rules.

Testing:
- Dedicated tests exist at tests/rules/valid-annotation-format.test.ts:
  - File header:
    - `* Tests for: docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md`
    - `* @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md`
    - `* @req REQ-FORMAT-SPECIFICATION - Verify valid-annotation-format rule enforces annotation format syntax`
  - Uses ESLint RuleTester with `languageOptions: { parserOptions: { ecmaVersion: 2020 } }`, matching ESLint testing conventions.
  - Valid cases confirm acceptance of correctly formatted annotations:
    - Single-line story: `// @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md`.
    - Single-line req: `// @req REQ-EXAMPLE`.
    - Block comment with @story and @req on separate lines.
    - Multi-line story path across lines in a block: `@story docs/stories/005.0-` + `DEV-ANNOTATION-VALIDATION.story.md`.
    - Multi-line req id: `@req REQ-` + `EXAMPLE`.
    - JSDoc-style comments with leading `*` and extra spaces around tags and values, verifying flexible parsing.
  - Invalid cases verify specific failure conditions and messages:
    - Missing story path: `// @story` and block `/** * @story */` both expect `messageId: "invalidStoryFormat"` with the exact “Missing story path ... Expected a path like "docs/stories/005.0-DEV-EXAMPLE.story.md".” details string.
    - Invalid file extension: `// @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story` expects `invalidStoryFormat` with details including the invalid path and same example path.
    - Missing `.story.md` extension: `// @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION` similarly flagged invalid.
    - Disallowed traversal: `// @story ../docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md` is explicitly expected to fail, verifying REQ-PATH-FORMAT and path-safety behavior.
    - Missing req id (with and without trailing spaces) via `// @req` and `// @req `, plus block `/** * @req */`, all expecting `messageId: "invalidReqFormat"` with the “Missing requirement ID ... Expected an identifier like "REQ-EXAMPLE".” message.
    - Invalid req ids: `// @req invalid-format` and multi-line `@req invalid-` + `format` both expect `invalidReqFormat` with details indicating the reconstructed id `"invalid-format"` and the allowed character set.
  - Test names explicitly reference requirement IDs (e.g., `[REQ-PATH-FORMAT]`, `[REQ-MULTILINE-SUPPORT]`, `[REQ-FLEXIBLE-PARSING]`), providing strong requirement-level coverage.
- Global tests were executed using the project’s script:
  - Command: `npm test -- --verbose`.
  - This runs `jest --ci --bail --verbose` per package.json.
  - The captured output shows Jest executing with verbose logging and no reported failures or error summaries, indicating all Jest suites, including valid-annotation-format tests, passed successfully.

Documentation:
- docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md exists and:
  - Defines the release goal of validating @story and @req formats.
  - Lists the same requirements implemented in code: REQ-FORMAT-SPECIFICATION, REQ-SYNTAX-VALIDATION, REQ-PATH-FORMAT, REQ-REQ-FORMAT, REQ-MULTILINE-SUPPORT, REQ-FLEXIBLE-PARSING, REQ-ERROR-SPECIFICITY.
  - Provides examples of valid annotations (with .story.md extension, docs/stories-relative paths, and REQ-* ids) and invalid ones (missing extension, traversal like ../, invalid req formats, missing identifiers) that align with the rule’s regex and error messages.
  - States that tests are written and passing and that validation utilities are integrated with existing rules, consistent with observed code and test suite behavior.</evidence>
  <notes>All acceptance criteria and explicit requirements in docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md are satisfied. A dedicated ESLint rule (valid-annotation-format) validates @story and @req syntax and format according to the documented specification, including path structure, REQ-* identifier format, multi-line support, and flexible whitespace handling. The rule integrates with the existing plugin via src/index.ts and inspects all comments discovered in the file, thereby working alongside the function and branch annotation rules. Error handling is robust and produces clear, specific messages distinguishing missing from invalid values. Comprehensive Jest tests using ESLint RuleTester in tests/rules/valid-annotation-format.test.ts cover all listed requirements and match the documented examples. Running `npm test -- --verbose` completes without failures, confirming the implementation is correct and stable. Therefore, this story is fully implemented and passes.</notes>
</traceability>