<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/008.0-DEV-AUTO-FIX.story.md</specification>
  <status>PASSED</status>
  <last_validated>2025-11-21T08:32:28.352Z</last_validated>
  <last_modified>2025-11-21T07:04:44.915Z</last_modified>
  <evidence>Implementation and tests for Story docs/stories/008.0-DEV-AUTO-FIX.story.md are present and wired into the ESLint plugin:

1) Core auto-fix for missing @story (REQ-AUTOFIX-MISSING, REQ-AUTOFIX-SAFE, REQ-AUTOFIX-PRESERVE)
- Rule implementation: src/rules/require-story-annotation.ts
  - References this story and requirements:
    - File header:
      """
      * @story docs/stories/008.0-DEV-AUTO-FIX.story.md
      * @req REQ-AUTOFIX-MISSING - This rule supports auto-fixing missing @story annotations per Story 008.0 auto-fix behavior.
      * @req REQ-AUTOFIX-SAFE - Auto-fix behavior only inserts @story annotation JSDoc comments and never changes executable or runtime code.
      * @req REQ-AUTOFIX-PRESERVE - Auto-fix inserts a minimal placeholder JSDoc in a way that preserves existing surrounding formatting and structure.
      """
  - meta.fixable is set to "code":
    """ts
    meta: {
      ...,
      fixable: "code",
      messages: { missingStory: "Missing @story annotation for function '{{name}}' ..." },
      ...
    }
    """
  - create(context) delegates to buildVisitors, which in turn calls helper functions that attach fixes.

- Helper template and fix behavior: src/rules/helpers/require-story-helpers.ts and src/rules/helpers/require-story-core.ts
  - Built-in template:
    """ts
    const STORY_PATH = "docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md";
    const ANNOTATION = `/** @story ${STORY_PATH} */`;
    """
  - Fixer creators (minimal, conservative insertion):
    """ts
    export function createAddStoryFix(target: any) {
      function addStoryFixer(fixer: any) {
        const start = ...; // chooses appropriate range but does not alter existing code
        return fixer.insertTextBeforeRange([start, start], `${ANNOTATION}\n`);
      }
      return addStoryFixer;
    }

    export function createMethodFix(node: any) {
      function methodFixer(fixer: any) {
        const start = ...;
        return fixer.insertTextBeforeRange([start, start], `${ANNOTATION}\n  `);
      }
      return methodFixer;
    }
    """
  - Reporting with auto-fix and suggestion for functions (note fix property wired to createAddStoryFix):
    """ts
    function reportMissing(context, sourceCode, node, passedTarget?) {
      ...
      context.report({
        node: nameNode,
        messageId: "missingStory",
        data: { name },
        fix: createAddStoryFix(resolvedTarget),
        suggest: [{
          desc: `Add JSDoc @story annotation for function '${name}', e.g., ${ANNOTATION}`,
          fix: createAddStoryFix(resolvedTarget),
        }],
      });
    }
    """
  - Equivalent behavior for methods via reportMethod with createMethodFix.
  - hasStoryAnnotation() and related helpers ensure fixes are not applied when an annotation already exists, satisfying safety and preservation requirements.

- Visitor wiring: src/rules/helpers/require-story-visitors.ts
  - For each function-like node, the visitors call helperReportMissing/helperReportMethod, which trigger the above auto-fix logic.
  - Example for FunctionDeclaration:
    """ts
    function handleFunctionDeclaration(node: any) {
      console.debug("require-story-annotation:FunctionDeclaration", ...);
      if (!options.shouldProcessNode(node)) return;
      const target = resolveTargetNode(sourceCode, node);
      helperReportMissing(context, sourceCode, node, target);
    }
    """

2) Auto-fix for @story path format (REQ-AUTOFIX-FORMAT, REQ-AUTOFIX-SAFE, REQ-AUTOFIX-PRESERVE)
- Rule implementation: src/rules/valid-annotation-format.ts
  - Story and requirement references:
    """ts
    /**
     * Rule to validate @story and @req annotation format and syntax. When run with
     * ESLint's `--fix` option, this rule performs only safe @story path suffix
     * normalization ... in line with Story 008.0.
     *
     * @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md
     * @story docs/stories/008.0-DEV-AUTO-FIX.story.md
     * @req REQ-AUTOFIX-FORMAT
     * @req REQ-AUTOFIX-SAFE
     */
    """
  - fixable is configured:
    """ts
    meta: {
      ...,
      fixable: "code",
      /**
       * This rule's fixable support is limited to safe @story path suffix normalization per Story 008.0.
       * ...
       * @req REQ-AUTOFIX-SAFE
       * @req REQ-AUTOFIX-PRESERVE
       */
    }
    """
  - Safe suffix-fixing helper:
    """ts
    function getFixedStoryPath(original: string): string | null {
      if (original.includes("..")) {
        return null; // avoid ambiguous/traversal paths
      }
      if (/\.story\.md$/.test(original)) return null;
      if (/\.story$/.test(original)) return `${original}.md`;
      if (/\.md$/.test(original)) return original.replace(/\.md$/, ".story.md");
      return `${original}.story.md`;
    }
    """
  - Fix application limited to the exact path substring, preserving other text/whitespace:
    """ts
    function reportInvalidStoryFormatWithFix(context, comment, collapsed, fixed) {
      const sourceCode = context.getSourceCode();
      const commentText = sourceCode.getText(comment);
      const tagIndex = commentText.indexOf("@story");
      ...
      const fixRange: [number, number] = [start + valueStartInComment, start + valueEndInComment];

      context.report({
        node: comment as any,
        messageId: "invalidStoryFormat",
        data: { details: buildStoryErrorMessage("invalid", collapsed) },
        fix(fixer: any) {
          return fixer.replaceTextRange(fixRange, fixed);
        },
      });
    }
    """
  - validateStoryAnnotation only applies a fix when both safe and valid:
    - Computes collapsed path.
    - If it matches the strict pattern already, returns.
    - If whitespace issues exist, reports without fix.
    - Otherwise uses getFixedStoryPath(); only when the fixed path matches the required pattern does it call reportInvalidStoryFormatWithFix; else it only reports (no fix).

3) Tests explicitly for Story 008.0 auto-fix behavior (Core Functionality, Integration, Error Handling, UX)
- Dedicated test file: tests/rules/auto-fix-behavior-008.test.ts
  - Header ties this suite to the story and requirements:
    """ts
    /**
     * Tests for: docs/stories/008.0-DEV-AUTO-FIX.story.md
     * @story docs/stories/008.0-DEV-AUTO-FIX.story.md
     * @req REQ-AUTOFIX-MISSING - Verify ESLint --fix automatically adds missing @story annotations to functions
     * @req REQ-AUTOFIX-FORMAT - Verify ESLint --fix corrects simple annotation format issues for @story annotations
     */
    """

  - Auto-fix for missing @story on multiple function/method patterns:
    """ts
    functionRuleTester.run("require-story-annotation --fix", requireStoryRule, {
      valid: [
        { name: "[REQ-AUTOFIX-MISSING] already annotated function is unchanged", code: `/**...*/\nfunction alreadyAnnotated() {}` },
        { name: "[REQ-AUTOFIX-MISSING] already annotated class method is unchanged", code: `class A {\n  /** @story ... */\n  method() {}\n}` },
      ],
      invalid: [
        {
          name: "[REQ-AUTOFIX-MISSING] adds @story before function declaration when missing",
          code: `function autoFixMe() {}`,
          output: `/** @story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md */\nfunction autoFixMe() {}`,
          errors: [{ messageId: "missingStory", suggestions: [{ desc: ..., output: `/** @story ... */\nfunction autoFixMe() {}` }]],
        },
        {
          name: "[REQ-AUTOFIX-MISSING] adds @story before function expression when missing",
          code: `const fnExpr = function() {};`,
          output: `/** @story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md */\nconst fnExpr = function() {};`,
          ...
        },
        {
          name: "[REQ-AUTOFIX-MISSING] adds @story before class method when missing",
          code: `class C {\n  method() {}\n}`,
          output: `class C {\n  /** @story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md */\n  method() {}\n}`,
          ...
        },
        {
          name: "[REQ-AUTOFIX-MISSING] adds @story before TS declare function when missing",
          code: `declare function tsDecl(): void;`,
          output: `/** @story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md */\ndeclare function tsDecl(): void;`,
          languageOptions: { parser: require("@typescript-eslint/parser"), ... },
          ...
        },
        {
          name: "[REQ-AUTOFIX-MISSING] adds @story before TS method signature when missing",
          code: `interface D {\n  method(): void;\n}`,
          output: `/** @story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md */\ninterface D {\n  method(): void;\n}`,
          languageOptions: { parser: require("@typescript-eslint/parser"), ... },
          ...
        },
      ],
    });
    """
    - This verifies consistent, predictable behavior across different function/method patterns and that already-annotated code is not modified.

  - Auto-fix for path suffix normalization via valid-annotation-format:
    """ts
    formatRuleTester.run(
      "valid-annotation-format --fix simple @story extension issues",
      validAnnotationFormatRule as any,
      {
        valid: [
          {
            name: "[REQ-AUTOFIX-FORMAT] already-correct story path is unchanged",
            code: `// @story docs/stories/005.0-DEV-EXAMPLE.story.md`,
          },
        ],
        invalid: [
          {
            name: "[REQ-AUTOFIX-FORMAT] adds .md extension for .story path",
            code: `// @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story`,
            output: `// @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md`,
            errors: [{ messageId: "invalidStoryFormat" }],
          },
          {
            name: "[REQ-AUTOFIX-FORMAT] adds .story.md extension when missing entirely",
            code: `// @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION`,
            output: `// @story docs/stories/005.0-DEV-ANNOTATION-VALIDATION.story.md`,
            errors: [{ messageId: "invalidStoryFormat" }],
          },
        ],
      },
    );
    """
    - Valid cases show no change when annotations are correct (preservation of formatting/behavior).
    - Invalid cases assert specific before/after fix outputs for simple suffix issues.

- Targeted test run for this story's suite:
  - Command executed via tools:
    - `npm test -- --runInBand --verbose tests/rules/auto-fix-behavior-008.test.ts`
  - Output (truncated by tooling) shows rule debug logs (`require-story-annotation:create`, `FunctionDeclaration` etc.) and no Jest failures or error summaries, indicating the suite executes without reported test failures.

4) Documentation of auto-fix capabilities (Documentation acceptance criterion)
- User-facing rule documentation: user-docs/api-reference.md
  - traceability/require-story-annotation section:
    """md
    Description: Ensures every function declaration has a JSDoc comment with an `@story` annotation ...
    When run with `--fix`, the rule inserts a single-line placeholder JSDoc `@story` annotation above missing functions, methods, TypeScript declare functions, and interface method signatures using a built-in template aligned with Story 008.0. This template is currently fixed but structured for future configurability, and fixes are strictly limited to adding this placeholder annotation without altering the function body or changing any runtime behavior.
    """
    - This explicitly documents what `--fix` does, where it applies, and safety constraints.

  - traceability/valid-annotation-format section:
    """md
    Description: ... When run with `--fix`, the rule limits changes to safe `@story` path suffix normalization only—for example, adding `.md` when the path ends with `.story`, or adding `.story.md` when the base path has no extension—using targeted replacements implemented in the `getFixedStoryPath` and `reportInvalidStoryFormatWithFix` helpers. It does not change directories, infer new story names, or modify any surrounding comment text or whitespace, in line with Story 008.0; more advanced path normalization strategies and selective toggles to enable or disable specific auto-fix behaviors are not yet implemented.
    """
    - This describes the auto-fixable issues and constraints in plain language, matching the implemented logic and tests.

5) Story file and dependencies exist
- docs/stories/008.0-DEV-AUTO-FIX.story.md exists and describes exactly the behaviors implemented in the files above.
- Dependent stories referenced in code (003.0-DEV-FUNCTION-ANNOTATIONS, 005.0-DEV-ANNOTATION-VALIDATION, etc.) exist under docs/stories/*.story.md (confirmed via file listing).</evidence>
  <notes>All acceptance criteria for Story 008.0-DEV-AUTO-FIX are satisfied by the current implementation:

- Core Functionality: ESLint `--fix` auto-fixes missing @story annotations on a range of function-like constructs via `traceability/require-story-annotation`, and normalizes simple @story path suffix issues via `traceability/valid-annotation-format`. Both rules declare `meta.fixable = "code"` and provide concrete `fix` functions.
- Quality & Safety: Fixes are strictly limited to adding a placeholder @story JSDoc comment (no runtime code changes) and adjusting only the suffix portion of @story paths. Guard conditions (e.g., skipping paths containing `..`, requiring the fixed path to match the strict pattern, and checking for existing annotations) ensure conservative, non-destructive edits that preserve surrounding formatting.
- Integration & UX: The rules are standard ESLint RuleModule implementations, used with ESLint’s RuleTester in `tests/rules/auto-fix-behavior-008.test.ts`. Tests cover multiple node patterns and confirm that already-correct code is left unchanged, providing predictable behavior.
- Error Handling: When an annotation cannot be safely auto-fixed (e.g., missing values, whitespace issues, non-normalizable paths), the code reports detailed errors without applying fixes, per `validateStoryAnnotation` and its helper functions.
- Documentation: `user-docs/api-reference.md` documents the auto-fix behavior for both rules, including when fixes are applied, limitations, and safety constraints, aligned with the story description.

The story itself explicitly marks REQ-AUTOFIX-TEMPLATE and REQ-AUTOFIX-SELECTIVE as "not yet implemented" and describes them as future enhancements, so their absence in code does not violate this iteration's acceptance criteria. Based on the rule implementations, dedicated tests, and user documentation, this story is fully implemented and passes.</notes>
</traceability>