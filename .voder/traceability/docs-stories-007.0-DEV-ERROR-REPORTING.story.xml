<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/007.0-DEV-ERROR-REPORTING.story.md</specification>
  <status>FAILED</status>
  <last_validated>2025-11-21T01:24:42.915Z</last_validated>
  <last_modified>2025-11-19T04:17:32.813Z</last_modified>
  <evidence>1) Story file exists and is clearly a specification:
   - docs/stories/007.0-DEV-ERROR-REPORTING.story.md defines acceptance criteria and requirements REQ-ERROR-SPECIFIC, REQ-ERROR-LOCATION, REQ-ERROR-SUGGESTION, REQ-ERROR-CONTEXT, REQ-ERROR-CONSISTENCY, REQ-ERROR-SEVERITY.

2) Targeted tests for this story exist and pass:
   - tests/rules/error-reporting.test.ts:
     - Header:
       /**
        * Tests for: docs/stories/007.0-DEV-ERROR-REPORTING.story.md
        * @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md
        * @req REQ-ERROR-SPECIFIC - Specific details about what annotation is missing or invalid
        * @req REQ-ERROR-SUGGESTION - Suggest concrete steps to fix the issue
        * @req REQ-ERROR-CONTEXT - Include relevant context in error messages
        */
     - Uses RuleTester against src/rules/require-story-annotation.
     - invalid case asserts:
       - messageId: "missingStory"
       - data: { name: "bar" }
       - suggestions array with:
         - desc: "Add JSDoc @story annotation for function 'bar', e.g., /** @story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md */"
         - output: "/** @story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md */\nfunction bar() {}"
   - Command run for just this test file:
     - npm test -- --runInBand --verbose --testPathPatterns tests/rules/error-reporting.test.ts
     - Output shows Jest running in CI mode on that path with no reported failures; the tool returned success (non-zero exit would have been reported as an error by the runner).

3) Implementation of improved error reporting for require-story-annotation:
   - src/rules/require-story-annotation.ts:
     - meta.hasSuggestions = true
     - meta.messages:
       missingStory: "Missing @story annotation for function '{{name}}' (REQ-ANNOTATION-REQUIRED)"
   - src/rules/helpers/require-story-helpers.ts:
     - reportMissing(context, sourceCode, node, passedTarget?):
       - Computes functionName via extractName(...).
       - Skips if hasStoryAnnotation(sourceCode, node) is true.
       - Finds insertion target node.
       - Calls context.report({
           node: nameNode,
           messageId: "missingStory",
           data: { name },
           suggest: [
             {
               desc: `Add JSDoc @story annotation for function '${name}', e.g., ${ANNOTATION}`,
               fix: createAddStoryFix(resolvedTarget),
             },
           ],
         });
     - reportMethod(...) similarly reports with messageId "missingStory" and a suggestion using createMethodFix.
   - src/rules/helpers/require-story-visitors.ts:
     - handleFunctionDeclaration logs debug context and delegates to helperReportMissing, so the above reporting path is exercised for function declarations.

   This clearly satisfies, for require-story-annotation only:
   - REQ-ERROR-SPECIFIC (includes function name and explicitly states missing @story)
   - REQ-ERROR-SUGGESTION (ESLint suggestions with concrete fix text and autofix)
   - REQ-ERROR-CONTEXT (message includes requirement ID; suggestion shows example annotation format and story path).

4) Other validation rules show mixed / incomplete alignment with the story requirements:
   a) require-req-annotation (functions rule):
      - src/rules/require-req-annotation.ts:
        - meta.messages: { missingReq: "Missing @req annotation" }
        - create(context) -> FunctionDeclaration handler:
          - If no @req in JSDoc, context.report({
              node,
              messageId: "missingReq",
              fix(fixer) { return fixer.insertTextBefore(node, "/** @req <REQ-ID> */\n"); },
            })
        - No data (e.g., function name) is provided; message is generic.
        - No separate message template per REQ-ERROR-SPECIFIC or REQ-ERROR-CONTEXT (no indication of which function is affected in the message text itself).
      - This rule does provide an autofix (a concrete step), but:
        - It does not include function name in the message.
        - It does not include any contextual hint about valid @req format or linking to a story.
        - There is no test file specifically verifying enhanced, story-007-style error messaging for this rule.

   b) require-branch-annotation (branch rule):
      - src/rules/require-branch-annotation.ts:
        - meta.messages: { missingAnnotation: "Missing {{missing}} annotation on code branch" }
      - src/utils/branch-annotation-helpers.ts:
        - reportMissingStory(...) and reportMissingReq(...):
          - For the first missing @story, context.report with messageId "missingAnnotation", data: { missing: "@story" }, and a fixer that inserts a default comment: "// @story <story-file>.story.md".
          - For subsequent missing @story or @req, only messageId and data are reported; no fix.
        - Messages only say "Missing @story annotation on code branch" or "Missing @req annotation on code branch" (via data.missing), with no details about the particular branch (if/while/etc.) or any suggestion text beyond the first simple template.
      - This partially meets REQ-ERROR-SPECIFIC and REQ-ERROR-SUGGESTION (it says which annotation is missing and may insert a stub), but does not:
        - Supply richer context (e.g., which branch type, how to choose the correct story/req id).
        - Provide consistent message structure with require-story-annotation (different wording and no explicit function/branch identifiers in the message text).

   c) valid-annotation-format (format rule):
      - src/rules/valid-annotation-format.ts:
        - meta.messages:
          - invalidStoryFormat: "Invalid @story annotation format"
          - invalidReqFormat: "Invalid @req annotation format"
        - create(context).Program():
          - Walks comments, splits into lines, and when encountering @story or @req, uses regex to validate.
          - On invalid @story: context.report({ node: comment, messageId: "invalidStoryFormat" }).
          - On invalid @req: context.report({ node: comment, messageId: "invalidReqFormat" }).
        - No data fields (e.g., offending path or req id) are included.
        - No suggestions or autofixes are provided.
      - This clearly falls short of multiple story-007 requirements:
        - REQ-ERROR-SPECIFIC: Messages are generic; they do not indicate what was wrong about the specific annotation (no echo of the actual path / id, or which part violated the format).
        - REQ-ERROR-SUGGESTION: No suggestions or guidance on how to correct the format.
        - REQ-ERROR-CONTEXT: No mention of expected pattern in the message; context is only in the docs, not in the error itself.
        - REQ-ERROR-CONSISTENCY: Message shape and richness differ significantly from require-story-annotation and valid-story-reference.

   d) valid-story-reference (file validation rule, Story 006.0):
      - src/rules/valid-story-reference.ts:
        - meta.messages:
          - fileMissing: "Story file '{{path}}' not found"
          - invalidExtension: "Invalid story file extension for '{{path}}', expected '.story.md'"
          - invalidPath: "Invalid story path '{{path}}'"
          - fileAccessError: "Could not validate story file '{{path}}' due to a filesystem error: {{error}}. Please check file existence and permissions."
        - reportExistenceProblems() and processStoryPath() populate data.path and data.error, differentiating missing files from filesystem errors and including the underlying error message.
      - Tests (tests/rules/valid-story-reference.test.ts) verify REQ-ERROR-HANDLING and that fileAccessError carries the filesystem error text.
      - This rule is strongly aligned with story-007 style error reporting: specific, contextual, includes suggestions ("Please check file existence and permissions.").

   e) valid-req-reference (deep validation rule, Story 010.0):
      - src/rules/valid-req-reference.ts:
        - meta.messages:
          - reqMissing: "Requirement '{{reqId}}' not found in '{{storyPath}}'"
          - invalidPath: "Invalid story path '{{storyPath}}'"
        - validateReqLine() reports with data { reqId, storyPath }.
      - tests/rules/valid-req-reference.test.ts asserts the data is present.
      - This again matches REQ-ERROR-SPECIFIC and REQ-ERROR-CONTEXT well.

5) Documentation for error message formats:
   - docs/rules/require-story-annotation.md, valid-annotation-format.md, valid-story-reference.md, valid-req-reference.md exist and describe rule behavior and when violations occur.
   - However, there is no central or cross-rule documentation that defines a consistent error message format for all validation rules as described in the story (e.g., no shared section that specifies naming/terminology templates and severity patterns across rules).
   - The 007.0 story itself is not referenced in any rule documentation; enhancements are implicit only in code for specific rules (require-story-annotation, valid-story-reference, valid-req-reference).

6) Error location and ESLint integration:
   - All rules use context.report with a specific AST node, which means ESLint will always include file path and line/column in its standard output.
   - require-story-annotation adds function name via data.name and message interpolation ("function '{{name}}'").
   - Other rules (valid-annotation-format, require-req-annotation) do not surface the specific annotation text or target identifier in the message itself, relying only on ESLint's generic location reporting, contrary to the story's emphasis on rich, user-facing message content.

Overall, only a subset of rules have been upgraded to the richer error-reporting pattern and only partially, while the story explicitly states: "All validation rules provide specific, actionable error messages" and "+ All plugin rules use consistent error message format and terminology". valid-annotation-format and require-req-annotation in particular do not meet these requirements, and there is no unified documentation of message formats.</evidence>
  <notes>This is a valid user story/specification, and parts of it have been implemented (notably for the require-story-annotation, valid-story-reference, and valid-req-reference rules). The require-story-annotation rule now reports missing @story annotations with function names and ESLint suggestions, and tests in tests/rules/error-reporting.test.ts explicitly validate that behavior for this story. However, the story’s acceptance criteria and requirements are broader: they apply to all validation rules (function, branch, annotation-format, and file/req validation) and call for consistent, specific, contextual, and suggestive error messages across the plugin, as well as documented message formats.

Key gaps:
- The valid-annotation-format rule still uses generic messages without data (no offending path/ID, no suggestion, minimal context), which contradicts REQ-ERROR-SPECIFIC, REQ-ERROR-SUGGESTION, and REQ-ERROR-CONTEXT.
- The require-req-annotation rule message is generic ("Missing @req annotation") and lacks function-name data or contextual guidance in the message, and has no tests showing enhanced error reporting per this story.
- There is no central documentation that defines a consistent error message format and terminology across all validation rules as required by the story’s Documentation and REQ-ERROR-CONSISTENCY criteria.

Because not all validation rules have been updated to the specified standard and the documentation aspect is incomplete, not all acceptance criteria for 007.0-DEV-ERROR-REPORTING are met. Therefore, the story is currently FAILED rather than fully PASSED.</notes>
</traceability>