<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/007.0-DEV-ERROR-REPORTING.story.md</specification>
  <status>PASSED</status>
  <last_validated>2025-11-21T00:25:00.079Z</last_validated>
  <last_modified>2025-11-19T04:17:32.813Z</last_modified>
  <evidence>1) Dedicated tests exist for this story:
- File: tests/rules/error-reporting.test.ts
- Header:
  /**
   * Tests for: docs/stories/007.0-DEV-ERROR-REPORTING.story.md
   * @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md
   * @req REQ-ERROR-SPECIFIC - Specific details about what annotation is missing or invalid
   * @req REQ-ERROR-SUGGESTION - Suggest concrete steps to fix the issue
   * @req REQ-ERROR-CONTEXT - Include relevant context in error messages
   */
- The test suite "Error Reporting Enhancements for require-story-annotation (Story 007.0-DEV-ERROR-REPORTING)" runs the require-story-annotation rule and asserts:
  - A valid example with an existing @story annotation.
  - An invalid example for a function `bar` with no @story, expecting:
    - errors[0].messageId === "missingStory"
    - errors[0].data === { name: "bar" }
    - errors[0].suggestions[0].desc === "Add JSDoc @story annotation for function 'bar', e.g., /** @story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md */"
    - errors[0].suggestions[0].output === "/** @story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md */\nfunction bar() {}"

2) Implementation of enhanced error reporting for missing @story annotations (core of this story):
- File: src/rules/require-story-annotation.ts
  - meta:
    - hasSuggestions: true
    - messages: {
        missingStory: "Missing @story annotation (REQ-ANNOTATION-REQUIRED)",
      }
  - create(context) obtains sourceCode and passes control to buildVisitors with options.
- File: src/rules/helpers/require-story-helpers.ts
  - Constants:
    - STORY_PATH = "docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md";
    - ANNOTATION = `/** @story ${STORY_PATH} */`;
  - Function extractName(node) walks node/parents to derive a human-readable name, falling back to "(anonymous)".
  - Function hasStoryAnnotation(...) encapsulates multiple heuristics (jsdocHasStory, commentsBeforeHasStory, leadingCommentsHasStory, linesBeforeHasStory, parentChainHasStory, fallbackTextBeforeHasStory) inside a try/catch to avoid crashing on incomplete context.
  - Function reportMissing(context, sourceCode, node, passedTarget?):
    - Wrapped in try/catch for robustness.
    - Derives functionName via extractName(...).
    - Skips reporting if hasStoryAnnotation(...) returns true.
    - Resolves the correct insertion target using resolveTargetNode(...).
    - Calls context.report with:
      {
        node,
        messageId: "missingStory",
        data: { name },
        suggest: [
          {
            desc: `Add JSDoc @story annotation for function '${name}', e.g., ${ANNOTATION}`,
            fix: createAddStoryFix(resolvedTarget),
          },
        ],
      }
  - Function reportMethod(...) is analogous for method-like nodes and uses createMethodFix.
- File: src/rules/helpers/require-story-visitors.ts
  - In handleFunctionDeclaration(node):
    - Logs debug info (function name, file) to aid diagnosis.
    - Calls helperReportMissing(context, sourceCode, node, target);
  - Equivalent visitors exist for FunctionExpression, ArrowFunctionExpression, TSDeclareFunction, TSMethodSignature, and MethodDefinition, all ultimately invoking reportMissing/reportMethod.

3) Other validation rules already use specific, contextual messages and correct ESLint patterns (showing consistency across the plugin):
- src/rules/valid-story-reference.ts (Story 006.0-DEV-FILE-VALIDATION)
  - meta.messages:
    - fileMissing: "Story file '{{path}}' not found"
    - invalidExtension: "Invalid story file extension for '{{path}}', expected '.story.md'"
    - invalidPath: "Invalid story path '{{path}}'"
    - fileAccessError: "Could not validate story file '{{path}}' due to a filesystem error: {{error}}. Please check file existence and permissions."
  - Explicitly distinguishes between missing files and filesystem errors via normalizeStoryPath(...) and existenceResult.status ("missing" vs "fs-error").
  - Tests in tests/rules/valid-story-reference.test.ts assert these messageIds and verify that filesystem error cases produce fileAccessError diagnostics with appropriate error context (EACCES, EIO, etc.).

- src/rules/valid-req-reference.ts (Story 010.0-DEV-DEEP-VALIDATION)
  - meta.messages:
    - reqMissing: "Requirement '{{reqId}}' not found in '{{storyPath}}'"
    - invalidPath: "Invalid story path '{{storyPath}}'"
  - validateReqLine(...) and handleComment(...) include storyPath and reqId in the error data and messages.
  - Tests in tests/rules/valid-req-reference.test.ts verify that these messages are raised with the correct data (missing requirements, invalid/traversal/absolute paths).

- src/rules/valid-annotation-format.ts (Story 005.0-DEV-ANNOTATION-VALIDATION)
  - meta.messages:
    - invalidStoryFormat: "Invalid @story annotation format"
    - invalidReqFormat: "Invalid @req annotation format"
  - Inspects all comments and enforces precise patterns for story and req formats.
  - Tests in tests/rules/valid-annotation-format.test.ts assert these messageIds for various invalid formats.

- src/rules/require-branch-annotation.ts & src/utils/branch-annotation-helpers.ts (Story 004.0-DEV-BRANCH-ANNOTATIONS)
  - meta.messages.missingAnnotation: "Missing {{missing}} annotation on code branch".
  - reportMissingStory(...) and reportMissingReq(...) in branch-annotation-helpers.ts:
    - Provide targeted auto-fixes that insert `// @story <story-file>.story.md` or `// @req <REQ-ID>` comments when appropriate.
    - When auto-fix is not applied (second occurrence or dependent missing annotation), still report a clear message with data { missing: "@story" | "@req" }.
  - Tests in tests/rules/require-branch-annotation.test.ts assert both the messages (with data.missing) and the exact fixed output code, confirming actionable, consistent messaging.

4) Error handling and robustness for incomplete context:
- reportMissing(...) and reportMethod(...) in src/rules/helpers/require-story-helpers.ts are both wrapped in try/catch with no rethrow, ensuring that malformed AST nodes or unusual sourceCode implementations do not crash ESLint; instead, the rule silently skips reporting for those pathological cases.
- hasStoryAnnotation(...) also uses a try/catch when combining multiple heuristics to avoid throwing when comment APIs are partially unavailable.
- valid-story-reference.ts and valid-req-reference.ts handle filesystem and path anomalies with dedicated, contextual errors (invalidPath, fileAccessError) rather than throwing.

5) ESLint best practices and integration:
- All rules use meta.messages with messageIds and placeholders, and invoke context.report({ node, messageId, data, fix/suggest }) in alignment with ESLint guidance.
- Suggestions are provided via the suggest array with desc and fix, as described in docs/custom-rules-development-guide.md under "Providing Suggestions".
- The plugin uses RuleTester for all rule tests, including error-reporting.test.ts, ensuring proper integration with ESLint’s reporting and suggestion mechanisms.

6) Tests executed and passing:
- Command executed: npm test -- --ci --no-watch --runInBand --verbose
- Underlying test runner: jest --ci --bail --no-watch --runInBand --verbose
- The run completed without failures (tool returned successfully). During execution, debug logs from require-story-annotation and require-story-visitors were printed, indicating that the rule and visitors (including the enhanced error-reporting paths) were exercised. Because tests/rules/error-reporting.test.ts is part of the Jest suite and no failures were reported, all expectations for story 007.0 (REQ-ERROR-SPECIFIC, REQ-ERROR-SUGGESTION, REQ-ERROR-CONTEXT) are currently passing.</evidence>
  <notes>Based on the implementation and tests, story 007.0-DEV-ERROR-REPORTING is implemented and validated.

Mapping to acceptance criteria:
- Core Functionality: The primary rule targeted by this story, require-story-annotation, now emits a specific error (messageId: "missingStory") and uses helpers (reportMissing/reportMethod) that:
  - Determine the function/method name via extractName.
  - Check for existing annotations via hasStoryAnnotation.
  - Report a problem only when genuinely missing.
  - Provide an explicit suggestion describing the fix and an auto-fix that inserts a correctly formatted @story annotation.
  Other validation rules (valid-story-reference, valid-req-reference, valid-annotation-format, require-branch-annotation) already use specific, contextual message templates and, where applicable, auto-fixes or detailed error messages. This satisfies the requirement that validation rules provide specific, actionable feedback rather than generic failures.

- Quality Standards (ESLint best practices): All rules define meta.messages and refer to them via messageId; they use type: "problem", appropriate docs.description, and include hasSuggestions or fixable where relevant. Suggestions for require-story-annotation are provided via the suggest API, consistent with the documented patterns in docs/custom-rules-development-guide.md.

- Integration: Error reporting is done exclusively through context.report with node references, allowing ESLint to attach file path and precise location data. The RuleTester-based tests confirm the rules integrate correctly with ESLint’s reporting and suggestion mechanisms.

- User Experience: For missing @story on functions/methods, the user sees a clear diagnostic ("Missing @story annotation (REQ-ANNOTATION-REQUIRED)") at the function location, with additional context provided via suggestion descriptions that include the concrete function name and an example annotation using the canonical story path. Branch annotation and story/req reference rules include explicit placeholders for the missing or invalid element (e.g., '{{path}}', '{{reqId}}', '{{storyPath}}') in their messages, aiding quick diagnosis.

- Error Handling: The helper functions are defensive: they wrap complex detection and reporting logic in try/catch blocks so that incomplete or unexpected context does not crash the rule. File-validation rules distinguish between missing files and filesystem errors and report a dedicated fileAccessError with the underlying error message, ensuring that unexpected IO conditions are communicated clearly but do not break lint execution.

- Documentation: The story itself documents the intent, requirements, and acceptance criteria for error reporting. Additionally, docs/custom-rules-development-guide.md provides a shared reference for how rules should structure messages and suggestions (messageIds, placeholders, suggest API), which the implemented rules follow. The dedicated tests in tests/rules/error-reporting.test.ts explicitly reference this story and its requirements, serving as executable documentation of the expected behavior.

Given the presence of a story-specific test suite tied directly to docs/stories/007.0-DEV-ERROR-REPORTING.story.md, the passing Jest run, and the concrete implementations in the rules and helpers, all acceptance criteria for this story are considered satisfied in the current codebase.</notes>
</traceability>