<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/007.0-DEV-ERROR-REPORTING.story.md</specification>
  <status>FAILED</status>
  <last_validated>2025-11-21T02:46:05.244Z</last_validated>
  <last_modified>2025-11-19T04:17:32.813Z</last_modified>
  <evidence>Key implementation and tests related to Story 007.0-DEV-ERROR-REPORTING:

1) Story-specific tests
- tests/rules/error-reporting.test.ts
  - Header explicitly ties tests to this story:
    - `@story docs/stories/007.0-DEV-ERROR-REPORTING.story.md`
    - `@req REQ-ERROR-SPECIFIC`, `@req REQ-ERROR-SUGGESTION`, `@req REQ-ERROR-CONTEXT`
  - Verifies for missing @story on a function:
    - `messageId: "missingStory"`
    - `data: { name: "bar" }` (function name is included)
    - `suggestions` with `desc` and full `output` code showing how to fix:
      - "Add JSDoc @story annotation for function 'bar', e.g., /** @story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md */"
  - Confirms require-story-annotation rule now produces specific, actionable messages and suggestions for this scenario.

2) Rule: require-story-annotation (functions)
- src/rules/require-story-annotation.ts
  - meta.messages:
    - `missingStory: "Missing @story annotation for function '{{name}}' (REQ-ANNOTATION-REQUIRED)"`
    - Uses ESLint best practices: messageId + placeholder `{{name}}`.
  - meta.hasSuggestions = true.
  - create(context) delegates to helpers/buildVisitors.
- src/rules/helpers/require-story-helpers.ts
  - `extractName(node)` walks node/parents to find a function or method name (Identifier, key, literal key name). This supports REQ-ERROR-LOCATION and REQ-ERROR-SPECIFIC.
  - `reportMissing(context, sourceCode, node, passedTarget?)`:
    - Safely computes `functionName` via extractName.
    - Checks existing annotations via `hasStoryAnnotation(...)` (with try/catch to avoid crashes when context is incomplete).
    - Uses `context.report({ node: nameNode, messageId: 'missingStory', data: { name }, suggest: [...] })`.
    - Suggest object:
      - `desc: "Add JSDoc @story annotation for function '${name}', e.g., ${ANNOTATION}"`
      - `fix: createAddStoryFix(resolvedTarget)`
  - `reportMethod` similarly reports missing story on methods with a targeted suggestion.
  - Both helpers use try/catch internally to avoid throwing when context is odd (edge-case/error resilience).
- src/rules/helpers/require-story-visitors.ts
  - Visitors call `helperReportMissing(context, sourceCode, node, target)` for functions, arrows, TS declare functions, TS method signatures, etc.
  - Adds debug logging, but error behavior still uses context.report from helpers.

3) Rule: require-branch-annotation (branches)
- src/rules/require-branch-annotation.ts
  - meta.messages:
    - `missingAnnotation: "Missing {{missing}} annotation on code branch"` (placeholder will be `@story` or `@req`).
  - fixable: "code".
  - create(context) uses branch-annotation-helpers.
- src/utils/branch-annotation-helpers.ts
  - `reportMissingStory`:
    - When `storyFixCountRef.count === 0`, reports:
      - `messageId: 'missingAnnotation', data: { missing: '@story' }`
      - With a fixer that inserts `// @story <story-file>.story.md` at the correct location.
    - On subsequent branches, reports the same messageId without a fix.
  - `reportMissingReq` uses analogous pattern for `@req` with fix `// @req <REQ-ID>`.
  - `reportMissingAnnotations` runs both in a controlled way based on missing flags.
- tests/rules/require-branch-annotation.test.ts
  - Valid and invalid cases verify messages and fix outputs, e.g.:
    - `errors: [{ messageId: 'missingAnnotation', data: { missing: '@story' } }, ... ]`
    - `output` strings show inserted `// @story <story-file>.story.md` and/or `// @req <REQ-ID>`.
  - Confirms messages are correctly wired to ESLint and fixes are applied.

4) Rule: valid-annotation-format (annotation syntax)
- src/rules/valid-annotation-format.ts
  - Builds very detailed error text:
    - `buildStoryErrorMessage(kind, value)`:
      - missing: `Missing story path for @story annotation. Expected a path like "docs/stories/005.0-DEV-EXAMPLE.story.md".`
      - invalid: `Invalid story path "${value}" for @story annotation. Expected a path like "docs/stories/005.0-DEV-EXAMPLE.story.md".`
    - `buildReqErrorMessage(kind, value)`:
      - missing: `Missing requirement ID for @req annotation. Expected an identifier like "REQ-EXAMPLE".`
      - invalid: `Invalid requirement ID "${value}" for @req annotation. Expected an identifier like "REQ-EXAMPLE" (uppercase letters, numbers, and dashes only).`
  - meta.messages uses these via placeholders:
    - `invalidStoryFormat: "{{details}}"`
    - `invalidReqFormat: "{{details}}"`
  - `processComment` and its helpers handle multi-line, JSDoc style, and whitespace, and report via `context.report({ messageId, data: { details } })` with appropriate node.
  - These messages give clear problem descriptions and example correct formats, matching ESLint best practices.
- tests/rules/valid-annotation-format.test.ts
  - Extensively asserts on `messageId` and `data.details` for many invalid cases:
    - Missing story/req values, invalid formats, path traversal, multi-line cases, etc.
  - This directly verifies REQ-ERROR-SPECIFIC and REQ-ERROR-CONTEXT for format validation.

5) Rule: valid-story-reference (story file existence)
- src/rules/valid-story-reference.ts
  - meta.messages include:
    - `fileMissing: "Story file '{{path}}' not found"`
    - `invalidExtension: "Invalid story file extension for '{{path}}', expected '.story.md'"`
    - `invalidPath: "Invalid story path '{{path}}'"`
    - `fileAccessError: "Could not validate story file '{{path}}' due to a filesystem error: {{error}}. Please check file existence and permissions."`
  - `reportExistenceProblems` distinguishes between:
    - status "missing" -> reports `fileMissing` with `path`.
    - status "fs-error" -> reports `fileAccessError` with detailed `error` string created from Error or raw value.
  - `processStoryPath` handles absolute paths, traversal, and extension issues, reporting via these messages.
  - This implements clear, context-rich diagnostics and explicit user guidance for permission/IO errors.
- tests/rules/valid-story-reference.test.ts
  - Valid/invalid tests confirm messages for `fileMissing`, `invalidExtension`, and `invalidPath`.
  - Additional block `Valid Story Reference Rule Error Handling` uses mocked fs to force errors, then:
    - Confirms `storyExists` does not throw and returns false on EACCES/EIO.
    - Confirms rule reports `fileAccessError` with error data matching `/EACCES/i` or `/EIO/i`.
  - These tests show robust error handling and clear messaging for edge-case filesystem failures.

6) Rule: valid-req-reference (requirement existence in story files)
- src/rules/valid-req-reference.ts
  - meta.messages:
    - `reqMissing: "Requirement '{{reqId}}' not found in '{{storyPath}}'"`
    - `invalidPath: "Invalid story path '{{storyPath}}'"`
  - `validateReqLine` checks for path traversal, absolute paths, and then loads/caches story file contents, extracting `REQ-...` IDs. If missing, reports `reqMissing` with both `reqId` and `storyPath`.
- tests/rules/valid-req-reference.test.ts
  - Asserts on `reqMissing` and `invalidPath` messages, including both the requirement ID and story path.
  - Confirms deep-validation style error messages are specific and contextual.

7) Rule: require-req-annotation (functions @req)
- src/rules/require-req-annotation.ts
  - meta.messages:
    - `missingReq: "Missing @req annotation"`
  - create(context) reports:
    - `context.report({ node, messageId: 'missingReq', fix(fixer) { return fixer.insertTextBefore(node, '/** @req <REQ-ID> */\n'); } })`.
  - This provides an auto-fix that inserts a placeholder `@req` JSDoc above the function, but the message itself is minimal and does not include function name or tailored guidance.
- tests/rules/require-req-annotation.test.ts
  - Verify `messageId: 'missingReq'` and full `output` with `/** @req <REQ-ID> */` inserted.
  - Confirms rule behavior is wired correctly, but still using a generic message string.

8) Integration, CLI, and general guidance
- src/index.ts dynamically loads rules and, on failure, produces clear diagnostic messages via a fallback rule, though this is more plugin-load-error oriented than annotation-focused.
- docs/eslint-plugin-development-guide.md and docs/custom-rules-development-guide.md document ESLint best practices for error messages (meta.messages, messageId usage, placeholders, suggestions) but do not list a unified, project-specific error-message format for all rules.
- Jest test suite (npm test) is passing, and includes all the rule tests above.

Gaps against Story 007 requirements:
- REQ-ERROR-SPECIFIC / Core Functionality: Most validation rules (require-story-annotation, require-branch-annotation, valid-annotation-format, valid-story-reference, valid-req-reference) provide detailed, actionable messages and in many cases example fixes. However, require-req-annotation still uses a very generic message string: "Missing @req annotation" without function name or additional context. While the auto-fix helps, the message itself does not meet the same specificity standard set by other rules and by this story.
- REQ-ERROR-SUGGESTION: Some rules use ESLint suggestions (require-story-annotation via `suggest`) or auto-fixes (require-branch-annotation, require-req-annotation). The story emphasizes suggestions in the messages; require-req-annotation relies solely on a fix with no explanatory description of the fix in the message template, making suggestions less clear than for @story or branch rules.
- REQ-ERROR-CONTEXT: Format and file-validation rules provide strong contextual messages, but no rule surfaces "available story files" or similar deeper context described in the requirement. Context is partial (expected formats, offending IDs/paths, filesystem error text) but not complete per the spec wording.
- REQ-ERROR-LOCATION: Functions and methods get name-based context via require-story-annotation. Other rules rely on ESLint's filename/line reporting but do not enrich messages with additional location details like function/branch names. There are no tests or implementations that explicitly add function name/location details to require-req-annotation or branch/file/deep validation messages.
- REQ-ERROR-CONSISTENCY: While most rules use meta.messages and messageIds consistently, there are visible differences in message richness between rules (e.g., require-req-annotation vs. others). There is no single documented pattern enforced across all rules.
- REQ-ERROR-SEVERITY: The specification states: "Error severity levels are appropriate (error for missing annotations, warning for format issues)." In the current implementation:
  - All rules, including format validation (valid-annotation-format) and file/deep reference validation, are configured as `type: 'problem'` and are used as "error" in the recommended/strict configs in src/index.ts.
  - There is no differentiation where format issues are warnings and missing annotations are errors by default, as described in REQ-ERROR-SEVERITY.
- Documentation Criterion: There is general documentation about how to write ESLint messages and suggestions, but no dedicated, explicit documentation of this plugin's error message formats or a cross-rule convention document specific to Story 007.
</evidence>
  <notes>The implementation clearly addresses many aspects of Story 007.0-DEV-ERROR-REPORTING, especially for the require-story-annotation, branch-annotation, format-validation, story-reference, and req-reference rules. These rules use ESLint messageIds, placeholders, and often provide detailed messages with examples and explicit suggestions or fixes, and there is a dedicated Jest test file (tests/rules/error-reporting.test.ts) tied directly to this story that validates enhanced require-story-annotation messaging.

However, the story requires all validation rules to provide specific, actionable, and context-rich error messages, with appropriate severity levels (errors for missing annotations, warnings for format issues) and documented, consistent formats across rules. In the current codebase:
- The require-req-annotation rule still uses a generic message ("Missing @req annotation") with no function name or additional context, and no message-level suggestion description, falling short of the specificity and guidance provided by other rules and required by REQ-ERROR-SPECIFIC and REQ-ERROR-SUGGESTION.
- Severity levels are not differentiated as described: format and reference validation rules are configured as errors, not warnings, contrary to REQ-ERROR-SEVERITY.
- There is no dedicated documentation describing a unified error message format across rules; existing docs are general ESLint guidance rather than a project-specific standard that fulfills the storyâ€™s documentation acceptance criterion.

Because not all requirements and acceptance criteria for this story are fully met and consistently applied across all validation rules, this story cannot be considered fully implemented. The status is therefore FAILED.</notes>
</traceability>