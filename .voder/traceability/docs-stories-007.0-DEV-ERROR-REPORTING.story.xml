<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/007.0-DEV-ERROR-REPORTING.story.md</specification>
  <status>PASSED</status>
  <last_validated>2025-11-21T22:17:01.174Z</last_validated>
  <last_modified>2025-11-21T17:57:51.542Z</last_modified>
  <evidence>Story file exists and matches spec path:
- docs/stories/007.0-DEV-ERROR-REPORTING.story.md

Dedicated test suite for this story:
- tests/rules/error-reporting.test.ts
  - Header explicitly ties tests to this story and its requirements:
    /**
     * Tests for: docs/stories/007.0-DEV-ERROR-REPORTING.story.md
     * @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md
     * @req REQ-ERROR-SPECIFIC - Specific details about what annotation is missing or invalid
     * @req REQ-ERROR-SUGGESTION - Suggest concrete steps to fix the issue
     * @req REQ-ERROR-CONTEXT - Include relevant context in error messages
     * @req REQ-ERROR-LOCATION - Include precise location information in error messages
     */

Error reporting behavior for require-story-annotation is explicitly tested:
- tests/rules/error-reporting.test.ts
  - Constructs a synthetic context and AST for function `bar` with no @story:
    const code = "function bar() {}";
    const reported: any[] = [];
    const context: any = { ... report: (descriptor: any) => { reported.push(descriptor); } ... };
    const listeners = rule.create(context);
    ... listeners.Program(programNode); listeners.FunctionDeclaration(functionNode);
  - Asserts specific message template and placeholders:
    const template = rule.meta?.messages?.missingStory as string;
    expect(template.includes("{{name}}"))toBe(true);
  - Asserts data wiring and function name exposure:
    expect(error.messageId).toBe("missingStory");
    expect(error.data).toEqual({ name: "bar", functionName: "bar" });
  - Asserts suggestions are present and actionable:
    expect(Array.isArray(error.suggest)).toBe(true);
    const suggestion = error.suggest[0];
    expect(suggestion.desc).toBe(
      "Add JSDoc @story annotation for function 'bar', e.g., /** @story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md */",
    );
    expect(suggestion.fix).toBeDefined();

Rule implementations referenced in the story exist and use clear, specific meta.messages with placeholders:

1) traceability/require-story-annotation
- File: src/rules/require-story-annotation.ts
- Traceability includes this story:
  * @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md
  * @req REQ-ERROR-MSG-CONTENT
  * @req REQ-ERROR-MSG-PLACEHOLDER
  * @req REQ-ERROR-MSG-ACTIONABLE
- Error message definition:
  meta: {
    ...
    hasSuggestions: true,
    messages: {
      missingStory:
        "Function '{{name}}' must have an explicit @story annotation. Add a JSDoc or line comment with @story that points to the implementing story file (for example, docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md).",
    },
    ...
  }
- Satisfies:
  - REQ-ERROR-SPECIFIC: names the exact function via {{name}} and error.data.functionName
  - REQ-ERROR-SUGGESTION: concrete remediation text plus suggest API
  - REQ-ERROR-LOCATION: ESLint context.report location + functionName in data
  - REQ-ERROR-CONSISTENCY: uses a shared meta.messages template and placeholder pattern

2) traceability/require-req-annotation
- File: src/rules/require-req-annotation.ts
- Error message definition with functionName placeholder and guidance:
  messages: {
    /** @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md ... */
    missingReq:
      "Function '{{functionName}}' is missing a required @req annotation. Add a JSDoc or line comment with @req (for example, '@req REQ-EXAMPLE') referencing the appropriate requirement from the story file.",
  }
- Satisfies:
  - REQ-ERROR-SPECIFIC: includes functionName
  - REQ-ERROR-CONTEXT: explains expected @req format and example ID
  - REQ-ERROR-CONSISTENCY: uses shared function-related error pattern

3) traceability/require-branch-annotation
- File: src/rules/require-branch-annotation.ts
- Message for branch-related errors:
  messages: {
    /** @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md
     * @req REQ-ERROR-CONSISTENCY - Use shared branch error message convention with {{missing}} placeholder
     */
    missingAnnotation: "Branch is missing required annotation: {{missing}}.",
  }
- Matches story’s branch pattern: "Branch is missing required annotation: {{missing}}."

4) traceability/valid-annotation-format
- File: src/rules/valid-annotation-format.ts
- Messages use shared {{details}} convention:
  meta: {
    messages: {
      /** @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md
       * @req REQ-ERROR-SPECIFIC
       * @req REQ-ERROR-CONTEXT
       * @req REQ-ERROR-CONSISTENCY
       */
      invalidStoryFormat: "Invalid annotation format: {{details}}.",
      /** @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md
       * @req REQ-ERROR-SPECIFIC
       * @req REQ-ERROR-CONTEXT
       * @req REQ-ERROR-CONSISTENCY
       */
      invalidReqFormat: "Invalid annotation format: {{details}}.",
    },
    ...
  }
- Helper functions build detailed human-readable details (context, expected patterns):
  - buildStoryErrorMessage(kind, value) returns messages like:
    - "Missing story path for @story annotation. Expected a path like \"docs/stories/005.0-DEV-EXAMPLE.story.md\"."
    - "Invalid story path \"...\" for @story annotation. Expected a path like \"docs/stories/005.0-DEV-EXAMPLE.story.md\"."
  - buildReqErrorMessage(kind, value) returns messages like:
    - 'Missing requirement ID for @req annotation. Expected an identifier like "REQ-EXAMPLE".'
    - 'Invalid requirement ID "..." for @req annotation. Expected an identifier like "REQ-EXAMPLE" (uppercase letters, numbers, and dashes only).'
- Reporting uses these as {{details}}:
  context.report({ messageId: "invalidStoryFormat", data: { details: buildStoryErrorMessage(...) } });
  context.report({ messageId: "invalidReqFormat", data: { details: buildReqErrorMessage(...) } });

5) traceability/valid-story-reference
- File: src/rules/valid-story-reference.ts
- Messages defined with {{path}} and detailed wording:
  messages: {
    /** @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md
     * @story docs/stories/006.0-DEV-FILE-VALIDATION.story.md */
    fileMissing: "Story file '{{path}}' not found",
    /** @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md
     * @story docs/stories/006.0-DEV-FILE-VALIDATION.story.md */
    invalidExtension:
      "Invalid story file extension for '{{path}}', expected '.story.md'",
    /** @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md
     * @story docs/stories/006.0-DEV-FILE-VALIDATION.story.md */
    invalidPath: "Invalid story path '{{path}}'",
    /** @story docs/stories/006.0-DEV-FILE-VALIDATION.story.md */
    fileAccessError:
      "Could not validate story file '{{path}}' due to a filesystem error: {{error}}. Please check file existence and permissions.",
  }
- reportExistenceProblems() and processStoryPath() distinguish:
  - missing vs existing vs fs-error
  - invalid path traversal vs invalid extension
  - include OS error messages in fileAccessError

6) traceability/valid-req-reference
- File: src/rules/valid-req-reference.ts
- Messages for requirement lookup and invalid path:
  messages: {
    /** @story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
     * @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md */
    reqMissing: "Requirement '{{reqId}}' not found in '{{storyPath}}'",
    /** @story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
     * @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md */
    invalidPath: "Invalid story path '{{storyPath}}'",
  }
- validateReqLine() reports:
  - invalidPath when storyPath is absolute or contains traversal escaping cwd
  - reqMissing when requirement ID not found in story file (or file read failure)

Traceability annotations tie implementations back to this story:
- src/rules/require-story-annotation.ts, src/rules/require-branch-annotation.ts, src/rules/valid-annotation-format.ts, src/rules/valid-story-reference.ts, and src/rules/valid-req-reference.ts all include @story docs/stories/007.0-DEV-ERROR-REPORTING.story.md on relevant functions or meta.messages blocks, showing deliberate alignment with this story’s conventions.

Test execution evidence:
- Command (using project’s configured test script):
  npm test -- --ci --no-watch --runInBand --verbose
- Output (relevant excerpt):
  > eslint-plugin-traceability@1.0.5 test
  > jest --ci --bail --ci --no-watch --runInBand --verbose
  [multiple console.debug lines from require-story-annotation:create and FunctionDeclaration handlers]
  (No FAIL lines or failed suites reported.)
- This confirms tests including tests/rules/error-reporting.test.ts execute successfully and that the implemented error reporting behavior matches test expectations.

Alignment with story acceptance criteria:
- Core Functionality: All validation rules define specific, actionable messages using meta.messages, and tests verify this for require-story-annotation.
- Quality Standards: Messages follow ESLint best practices (messageId, placeholders, hasSuggestions) and are consistent across rules.
- Integration: Rules integrate with ESLint reporting via context.report; RuleTester-based tests pass.
- User Experience: Messages identify the problem, provide location via ESLint’s standard mechanisms plus data fields (functionName, path, reqId), and suggest concrete fixes where appropriate.
- Error Handling: valid-story-reference and valid-req-reference gracefully handle incomplete context and filesystem errors, differentiating error types in messages.
- Documentation: The story itself documents the formats; message templates in rule files match that documentation.</evidence>
  <notes>Story 007.0-DEV-ERROR-REPORTING is fully implemented. All referenced rules (require-story-annotation, require-req-annotation, require-branch-annotation, valid-annotation-format, valid-story-reference, valid-req-reference) expose clear, specific, and consistent error messages via meta.messages, using placeholders like {{functionName}}/name, {{missing}}, {{details}}, {{path}}/{{storyPath}}/{{reqId}} as described in the story. tests/rules/error-reporting.test.ts directly validates key requirements (specificity, suggestions, context, and location) for require-story-annotation, and the overall jest suite passes when run through the project’s npm test script. Error handling paths in valid-story-reference and valid-req-reference differentiate between missing files, invalid paths, and filesystem errors without crashing. Taken together, the concrete implementations and passing tests show that all acceptance criteria and listed requirements for this story are satisfied.</notes>
</traceability>