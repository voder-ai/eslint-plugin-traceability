<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/009.0-DEV-MAINTENANCE-TOOLS.story.md</specification>
  <status>FAILED</status>
  <last_validated>2025-11-21T05:04:36.517Z</last_validated>
  <last_modified>2025-11-19T04:17:32.839Z</last_modified>
  <evidence>Implementation exists for a dedicated maintenance module wired to this story:,- src/maintenance/index.ts exports maintenance APIs and is tagged with this story and requirements:
  ```ts
  /**
   * Maintenance Tools Module
   * @story docs/stories/009.0-DEV-MAINTENANCE-TOOLS.story.md
   * @req REQ-MAINT-DETECT
   * @req REQ-MAINT-UPDATE
   * @req REQ-MAINT-BATCH
   * @req REQ-MAINT-VERIFY
   * @req REQ-MAINT-REPORT
   * @req REQ-MAINT-SAFE
   */
  export { detectStaleAnnotations } from "./detect";
  export { updateAnnotationReferences } from "./update";
  export { batchUpdateAnnotations, verifyAnnotations } from "./batch";
  export { generateMaintenanceReport } from "./report";
  ```,- Detection (REQ-MAINT-DETECT) is implemented and tested:
  ```ts
  // src/maintenance/detect.ts
  /**
   * Detect stale annotation references that point to moved or deleted story files
   * @story docs/stories/009.0-DEV-MAINTENANCE-TOOLS.story.md
   * @req REQ-MAINT-DETECT - Detect stale annotation references
   */
  export function detectStaleAnnotations(codebasePath: string): string[] {
    if (!fs.existsSync(codebasePath) || !fs.statSync(codebasePath).isDirectory()) {
      return [];
    }
    const cwd = process.cwd();
    const baseDir = path.resolve(cwd, codebasePath);
    const stale = new Set<string>();
    const files = getAllFiles(codebasePath);
    for (const file of files) {
      const content = fs.readFileSync(file, "utf8");
      const regex = /@story\s+([^\s]+)/g;
      let match: RegExpExecArray | null;
      while ((match = regex.exec(content)) !== null) {
        const storyPath = match[1];
        const storyProjectPath = path.resolve(cwd, storyPath);
        const storyCodebasePath = path.resolve(baseDir, storyPath);
        if (!fs.existsSync(storyProjectPath) && !fs.existsSync(storyCodebasePath)) {
          stale.add(storyPath);
        }
      }
    }
    return Array.from(stale);
  }
  ```
  Tests:
  - tests/maintenance/detect.test.ts – detects stale annotations and empty case
  - tests/maintenance/detect-isolated.test.ts – handles non-existent directory, nested dirs, and permission errors,- Update (REQ-MAINT-UPDATE) is implemented and tested:
  ```ts
  // src/maintenance/update.ts
  /**
   * Update annotation references when story files are moved or renamed
   * @story docs/stories/009.0-DEV-MAINTENANCE-TOOLS.story.md
   * @req REQ-MAINT-UPDATE - Update annotation references
   */
  export function updateAnnotationReferences(
    codebasePath: string,
    oldPath: string,
    newPath: string,
  ): number {
    if (!fs.existsSync(codebasePath) || !fs.statSync(codebasePath).isDirectory()) {
      return 0;
    }
    let replacementCount = 0;
    const escapedOldPath = oldPath.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const regex = new RegExp(`(@story\\s*)${escapedOldPath}`, "g");
    const files = getAllFiles(codebasePath);
    for (const fullPath of files) {
      const stat = fs.statSync(fullPath);
      if (!stat.isFile()) continue;
      const content = fs.readFileSync(fullPath, "utf8");
      const newContent = content.replace(regex, (match, p1) => {
        replacementCount++;
        return `${p1}${newPath}`;
      });
      if (newContent !== content) {
        fs.writeFileSync(fullPath, newContent, "utf8");
      }
    }
    return replacementCount;
  }
  ```
  Tests:
  - tests/maintenance/update.test.ts – returns 0 when nothing updated
  - tests/maintenance/update-isolated.test.ts – actually updates @story paths and handles non-existent directory,- Batch operations and verification (REQ-MAINT-BATCH, REQ-MAINT-VERIFY) are implemented and tested:
  ```ts
  // src/maintenance/batch.ts
  export function batchUpdateAnnotations(
    codebasePath: string,
    mappings: { oldPath: string; newPath: string }[],
  ): number {
    let totalUpdated = 0;
    for (const { oldPath, newPath } of mappings) {
      totalUpdated += updateAnnotationReferences(codebasePath, oldPath, newPath);
    }
    return totalUpdated;
  }

  export function verifyAnnotations(codebasePath: string): boolean {
    const staleAnnotations = detectStaleAnnotations(codebasePath);
    return staleAnnotations.length === 0;
  }
  ```
  Tests:
  - tests/maintenance/batch.test.ts – batchUpdateAnnotations returns 0 for empty mappings; verifyAnnotations returns true when annotations are valid,- Reporting helper exists but does not meet the full REQ-MAINT-REPORT requirement:
  ```ts
  // src/maintenance/report.ts
  /**
   * Generate a report of maintenance operations performed
   * @story docs/stories/009.0-DEV-MAINTENANCE-TOOLS.story.md
   * @req REQ-MAINT-REPORT - Generate maintenance report
   * @req REQ-MAINT-SAFE - Ensure operations are safe and reversible
   */
  export function generateMaintenanceReport(codebasePath: string): string {
    const staleAnnotations = detectStaleAnnotations(codebasePath);
    if (staleAnnotations.length === 0) {
      return "";
    }
    return staleAnnotations.join("\n");
  }
  ```
  Tests:
  - tests/maintenance/report.test.ts – only checks empty-string when no stale annotations and that stale story names appear when present

  This report only lists missing story paths; it does NOT show which annotations were updated, where they were, or "why" in the sense required by `REQ-MAINT-REPORT` ("showing what annotations were updated and why"). There is no function that reports update operations at all.,- Safety and reversibility (REQ-MAINT-SAFE) are only partially addressed:
  - Some safety behaviors exist:
    - detectStaleAnnotations and updateAnnotationReferences both early-return for non-existent or non-directory codebase paths (tests in detect-isolated.test.ts and update-isolated.test.ts)
    - getAllFiles in src/maintenance/utils.ts validates directory existence before traversal.
  - However, there is **no implementation of reversibility** (e.g., backups, dry-run mode, or undo capability). Files are overwritten in-place in updateAnnotationReferences, and no record of prior content is kept. This does not fulfill "Ensure maintenance operations are reversible" from REQ-MAINT-SAFE.,- User Experience / Feedback acceptance criteria are only partially met:
  - Functions return simple signals:
    - detectStaleAnnotations: array of missing story paths
    - updateAnnotationReferences: numeric count of replacements
    - batchUpdateAnnotations: aggregate replacement count
    - verifyAnnotations: boolean
    - generateMaintenanceReport: newline-separated list of stale story paths
  - There is **no reporting of which specific annotations in which files were updated**, no differentiation of reasons (moved vs deleted), and no structured report showing "what was changed" beyond a raw count and list of missing paths.,- Documentation acceptance criterion is not met:
  - Searches show no user or developer documentation for these maintenance tools beyond the story file itself:
    - README.md contains no references to "maintenance", "detectStaleAnnotations", or "batchUpdateAnnotations" (search_file_content over README.md returned no matches).
    - No dedicated maintenance docs or examples in docs/: find_files with patterns like "*maintenance*" in docs returned 0 matches.
  - The only description is the story docs/stories/009.0-DEV-MAINTENANCE-TOOLS.story.md, which is a specification, not usage documentation with examples and best practices.,- Tests are present and passing for maintenance tools and are explicitly tied to this story:
  - tests/maintenance/*.test.ts files all include headers such as:
    ```ts
    /**
     * Tests for: docs/stories/009.0-DEV-MAINTENANCE-TOOLS.story.md
     * @story docs/stories/009.0-DEV-MAINTENANCE-TOOLS.story.md
     * @req REQ-MAINT-DETECT - Detect stale annotation references
     */
    ```
  - `npm test -- --verbose` runs Jest (`jest --ci --bail --verbose`) without reporting any failed tests, indicating all current tests (including maintenance tests) pass.</evidence>
  <notes>This story IS a concrete specification for functionality and it has a substantial implementation (maintenance APIs under src/maintenance with accompanying tests). Core requirements REQ-MAINT-DETECT, REQ-MAINT-UPDATE, REQ-MAINT-BATCH, and REQ-MAINT-VERIFY are implemented and tested. However, key acceptance criteria are not fully satisfied:

- REQ-MAINT-REPORT is only partially implemented: the current generateMaintenanceReport helper merely lists stale story paths and does not describe what annotations were updated, which locations were affected, or why they changed, as required by the story.
- REQ-MAINT-SAFE is not met regarding reversibility: maintenance operations overwrite files in place without any backup, dry-run, or rollback mechanism, so they are not inherently reversible.
- The acceptance criterion for Documentation is not satisfied: there is no README or docs page explaining these maintenance tools, their CLI (none exists), their programmatic usage, or best practices; only the story file describes the intent.

Because at least these acceptance criteria and requirements remain unmet, the implementation does not fully satisfy the story, so the assessment status is FAILED.</notes>
</traceability>