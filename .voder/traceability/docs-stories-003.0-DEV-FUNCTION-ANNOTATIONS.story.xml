<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md</specification>
  <status>PASSED</status>
  <last_validated>2025-11-21T22:20:17.414Z</last_validated>
  <last_modified>2025-11-21T08:46:49.489Z</last_modified>
  <evidence>Implementation and tests clearly target this story and its requirements:

1) Core rules and helpers
- src/rules/require-story-annotation.ts
  - Declares ESLint rule `require-story-annotation`.
  - File-level JSDoc:
    - `@story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md`
    - `@req REQ-ANNOTATION-REQUIRED` (plus auto-fix and error reporting reqs).
  - meta:
    - `type: "problem"`, `recommended: "error"`.
    - `messages.missingStory` gives clear, actionable guidance including example story path.
    - `schema[0].properties.scope.items.enum = DEFAULT_SCOPE` and `exportPriority` enum = EXPORT_PRIORITY_VALUES.
  - `create(context)`:
    - Reads options `{ scope, exportPriority }`.
    - Uses shared helper `shouldProcessNode` from `./helpers/require-story-helpers`.
    - Calls `buildVisitors(context, sourceCode, { shouldProcessNode, scope, exportPriority })` so detection/scope/priority logic is centralized.
    - Logs debug info for easier troubleshooting.

- src/rules/require-req-annotation.ts
  - Declares ESLint rule `require-req-annotation`.
  - Header JSDoc:
    - `@story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md`.
    - `@req REQ-ANNOTATION-REQUIRED`, `REQ-FUNCTION-DETECTION`, `REQ-TYPESCRIPT-SUPPORT`, `REQ-CONFIGURABLE-SCOPE`, `REQ-EXPORT-PRIORITY`.
  - meta:
    - `type: "problem"`, `fixable: "code"`, `recommended: "error"`.
    - `messages.missingReq` is specific and actionable: instructs adding `@req`, with example.
    - `schema` mirrors require-story-annotation: same `scope` and `exportPriority` types and enums.
  - `create(context)`:
    - Reads options `{ scope, exportPriority }`, defaulting to shared `DEFAULT_SCOPE` and `"all"`.
    - Uses the same shared `shouldProcessNode(node, scope, exportPriority)` helper.
    - Defines visitors for:
      - `FunctionDeclaration`
      - `FunctionExpression` (skips when parent is `MethodDefinition` to avoid double-processing class methods)
      - `MethodDefinition`
      - `TSDeclareFunction`
      - `TSMethodSignature`
    - All visitors call a single helper `runCheck(node)` => `checkReqAnnotation(context, node, { enableFix: false })`.

- src/rules/helpers/require-story-core.ts
  - Provides DEFAULT_SCOPE and exportPriority values used by `require-story-annotation` and exported via helpers:
    - `export const DEFAULT_SCOPE: string[] = ["FunctionDeclaration", "FunctionExpression", "MethodDefinition", "TSMethodSignature", "TSDeclareFunction"];`
    - `EXPORT_PRIORITY_VALUES = ["all", "exported", "non-exported"]`.
  - Implements fix generators:
    - `createAddStoryFix(target)` and `createMethodFix(node)` generate fixers that insert a `@story` JSDoc before the appropriate node (honoring export declarations where present).
  - Reporting helpers:
    - `reportMissing(context, sourceCode, node, target?)` resolves name & location, checks JSDoc for existing `@story`, and reports with `messageId: "missingStory"`, plus suggestions using `createAddStoryFix`.
    - `reportMethod(...)` similarly for methods, anchoring at the method name node.

- src/rules/helpers/require-story-helpers.ts
  - File-level `@story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md` and `@req REQ-ANNOTATION-REQUIRED`.
  - Defines shared constants for story path and annotation text:
    - `const STORY_PATH = "docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md";`
    - `const ANNOTATION = `/** @story ${STORY_PATH} */`;` used consistently in fixes & messages.
  - Detection helpers for `@story`:
    - `jsdocHasStory(sourceCode, node)` (uses `getJSDocComment`).
    - `commentsBeforeHasStory(sourceCode, node)` (uses `getCommentsBefore`).
    - `leadingCommentsHasStory(node)`.
    - `linesBeforeHasStory(...)`, `parentChainHasStory(...)`, `fallbackTextBeforeHasStory(...)` imported from IO helpers.
    - `hasStoryAnnotation(sourceCode, node)` combines all these with try/catch guards to handle malformed or missing APIs gracefully.
  - Node resolution and naming:
    - `resolveTargetNode(sourceCode, node)` chooses the correct target for inserting JSDoc (handles TSMethodSignature, function expressions in variable declarators, exported functions, and IIFEs).
    - `extractName(node)` walks node and its parents to derive a function/method name, returning `"(anonymous)"` when none.
  - Scope and export semantics:
    - `isExportedNode(node)` walks up parent chain to detect ExportNamed/ExportDefaultDeclaration.
    - `shouldProcessNode(node, scope, exportPriority="all")` implements common logic for both rules:
      - Returns false if `node.type` not in `scope`.
      - For `exportPriority="exported"`, enforces `isExportedNode(node) === true`.
      - For `"non-exported"`, enforces `!isExportedNode(node)`.

- src/rules/helpers/require-story-visitors.ts
  - Builds visitors for require-story-annotation, all tagged with story 003.0:
    - FunctionDeclaration => `handleFunctionDeclaration` uses `resolveTargetNode` and `reportMissing`.
    - FunctionExpression => `handleFunctionExpression` (skips when parent is `MethodDefinition`, so methods are handled via dedicated path).
    - MethodDefinition => `handleMethodDefinition` uses `helperReportMethod`.
    - TSDeclareFunction => `handleTSDeclareFunction`.
    - TSMethodSignature => `handleTSMethodSignature`.
    - ArrowFunctionExpression => `handleArrowFunctionExpression` (but only executed when `options.shouldProcessNode` returns true; since the `scope` enum and DEFAULT_SCOPE exclude `ArrowFunctionExpression`, arrow functions are *not* processed by default, matching the story requirement that they are excluded by default).
  - `buildVisitors(...)` merges all these into a single RuleListener used by the main rule.

- src/utils/annotation-checker.ts
  - Multiple JSDoc references to `docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md` and `REQ-ANNOTATION-*` requirements.
  - Shared parsing strategy for `@req` similar to `@story` helpers:
    - Uses `getJSDocComment(sourceCode, node)`, `getLeadingComments(node)`, `getCommentsBefore(sourceCode, node)`, `combineComments(...)`, `commentContainsReq(...)`.
    - Also implements line-based, parent-chain, and fallback-window detection: `linesBeforeHasReq`, `parentChainHasReq`, `fallbackTextBeforeHasReq` (adapted from the story-based helpers, using shared `LOOKBACK_LINES` and `FALLBACK_WINDOW` from IO helpers).
    - `hasReqAnnotation(jsdoc, comments, context, node)` centralizes detection, with try/catch to avoid breaking on malformed nodes.
  - Reporting and fix:
    - `getFixTargetNode(node)` mirrors the story logic to select a fix insertion point.
    - `createMissingReqFix(node)` inserts `"/** @req <REQ-ID> */\n"` before the fix target.
    - `reportMissing(context, node, enableFix=true)` uses `getNodeName(node)` and chooses an appropriate identifier/key as the error node; includes `data: { name, functionName: name }`.
    - `checkReqAnnotation(context, node, options)` combines everything: obtains sourceCode, pulls comments, computes `hasReq`, and calls `reportMissing` if needed.

2) Tests for this story
- tests/rules/require-story-annotation.test.ts
  - Header:
    - `* Tests for: docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md`
    - `@story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md`
    - `@req REQ-ANNOTATION-REQUIRED - Verify require-story-annotation rule enforces @story annotation on functions`.
  - Uses ESLint RuleTester with JS parser and (for TS cases) @typescript-eslint/parser.
  - Valid cases include:
    - FunctionDeclaration with JSDoc `@story`.
    - Function with line comment `// @story ...`.
    - FunctionExpression with `@story`.
    - Arrow function with `@story` (allowed but not required).
    - Class method with `@story`.
    - TSDeclareFunction and TSMethodSignature with `@story` and TS parser.
    - An unannotated arrow function is explicitly marked “allowed by default”, confirming exclusion of arrows.
  - Invalid cases verify enforcement and autofix for:
    - `FunctionDeclaration`, `FunctionExpression`, class methods, `TSDeclareFunction`, `TSMethodSignature` without `@story`.
    - `exportPriority` behavior: unexported functions ignored when `exportPriority: "exported"`; exported functions require annotation and are auto-fixed.
    - `scope` behavior: when `scope: ["FunctionDeclaration"]`, only function declarations are required to have @story.
  - Invalid tests assert:
    - `messageId: "missingStory"`.
    - Suggestion descriptions and full `output` strings, verifying the autofix behavior and insertion locations.

- tests/rules/require-req-annotation.test.ts
  - Header:
    - `* Tests for: docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md`
    - `@story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md`
    - `@req REQ-ANNOTATION-REQUIRED` (plus story 007.0 for error reporting).
  - Valid cases verify:
    - FunctionDeclaration with only `@req`.
    - Function with both `@story` and `@req`.
    - TSDeclareFunction and TSMethodSignature with `@req` and TS parser.
    - FunctionExpression (including TS contexts) with `@req`.
    - Methods in classes with `@req`.
    - Scope semantics: FunctionExpression ignored when `scope` only includes `FunctionDeclaration`.
    - Export priority semantics for exported vs non-exported functions/methods under `"exported"` and `"non-exported"`.
  - Invalid cases verify enforcement on the same function-like constructs as the story rule:
    - Missing `@req` on plain functions, functions with only `@story`, TS declare functions, TS method signatures.
    - FunctionExpressions (including anonymous and TS-specific ones), methods in classes and object literals.
    - Various combinations of `scope` and `exportPriority` all produce `messageId: "missingReq"` with appropriate `data: { name, functionName: ... }`.

- tests/rules/require-story-core-edgecases.test.ts
  - Header references `docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md` and `REQ-AUTOFIX`.
  - Covers edge conditions and error handling:
    - `createAddStoryFix(null)` gracefully falls back to `[0,0]` range and inserts `ANNOTATION` at start of file.
    - Behavior when `target.parent` is not an export and/or missing `range`.
    - Prefers `ExportDefaultDeclaration.range` when present.
    - Ensures `reportMissing` works even when `sourceCode` argument is `undefined` and context must supply `getSourceCode()`; uses a fake source without `getJSDocComment` to exercise that branch, proving resilient error handling around missing methods.

3) Documentation for this story
- docs/rules/require-story-annotation.md
  - Declares:
    - `@story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md`
    - `@req REQ-ANNOTATION-REQUIRED`.
  - Describes rule purpose, supported node types (FunctionDeclaration, FunctionExpression, MethodDefinition, TSDeclareFunction, TSMethodSignature).
  - Documents configuration options (`scope`, `exportPriority`), including full JSON schema and example ESLint configuration.
  - Provides correct and incorrect code examples, including TypeScript-specific usage.

- docs/rules/require-req-annotation.md
  - Declares:
    - `@story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md`
    - `@req REQ-ANNOTATION-REQUIRED`.
  - Documents same node-type set and option semantics as the story rule.
  - Describes behavior in terms of the same `scope` and `exportPriority` semantics, asserting that it mirrors `require-story-annotation`.
  - Includes realistic JS and TS examples for both correct and incorrect usage.

4) Test execution (direct evidence)
- Command run (targeted to this story's rules):
  - `npm test -- --ci --no-watch --runInBand --verbose --runTestsByPath tests/rules/require-story-annotation.test.ts tests/rules/require-req-annotation.test.ts`
- Tool response:
  - Shows Jest being invoked with the specified tests and extensive `console.debug` output from `require-story-annotation` visitors.
  - The command completed successfully without a "Command failed" error, implying both test files passed in full. Any Jest failure would have been surfaced as a non-zero exit and reported by the tool (as seen in a separate failing run for a non-existent `tests/index.test.ts`).

5) Cross-story traceability
- All key implementation files for these rules reference this specific story via `@story docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md` and the explicit requirement IDs (`REQ-FUNCTION-DETECTION`, `REQ-ANNOTATION-REQUIRED`, `REQ-CONFIGURABLE-SCOPE`, `REQ-EXPORT-PRIORITY`, `REQ-TYPESCRIPT-SUPPORT`, etc.), providing strong traceability between the story and implementation.

Overall, the code, tests, and documentation together provide concrete, verifiable evidence that the story's behavior has been implemented and validated.</evidence>
  <notes>All acceptance criteria and detailed requirements in docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md are satisfied:
- Core Functionality: `require-story-annotation` and `require-req-annotation` both operate over the same function-like constructs (FunctionDeclaration, FunctionExpression, MethodDefinition, TSDeclareFunction, TSMethodSignature) and share the same scope/exportPriority semantics via the common `shouldProcessNode` helper. Arrow functions are not in DEFAULT_SCOPE and are not configurable in the schema, so they are excluded by default from enforcement as required.
- Quality Standards: Both rules follow ESLint best-practice patterns (proper meta, messageIds, schema, and create hooks) and are extensively covered by RuleTester-based tests, including edge cases and autofix behavior.
- Integration: Tests explicitly exercise both JavaScript and TypeScript syntax (using @typescript-eslint/parser for TS) for all relevant node types, demonstrating correct behavior in both languages.
- User Experience: Error messages for missing @story and @req are clear, actionable, and include explicit guidance and examples. Reporting anchors errors on the function or method name identifier, satisfying the precise error-location requirement.
- Error Handling: JSDoc and comment parsing is defensive (with multiple guards and try/catch blocks) and dedicated edge-case tests confirm the rules handle missing or limited sourceCode APIs without crashing.
- Documentation: Both rules have dedicated docs under docs/rules/, including examples and configuration options, and they explicitly reference this story. While the require-req-annotation docs mention arrow functions conceptually, the implemented behavior matches the story’s explicit requirement that arrow functions are excluded by default.

Given the aligned implementation, comprehensive tests that explicitly reference this story, and working rule behavior validated via Jest, this story is fully implemented and passes.</notes>
</traceability>