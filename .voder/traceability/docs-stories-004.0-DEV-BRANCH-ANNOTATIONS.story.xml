<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/004.0-DEV-BRANCH-ANNOTATIONS.story.md</specification>
  <status>PASSED</status>
  <last_validated>2025-11-21T07:31:56.802Z</last_validated>
  <last_modified>2025-11-19T04:17:32.767Z</last_modified>
  <evidence>1) Rule implementation for branch annotations:
- File: src/rules/require-branch-annotation.ts
- Contains rule meta and logic to enforce @story/@req on branches, with direct story linkage:
  """
  /**
   * Rule to enforce @story and @req annotations on significant code branches.
   *
   * @story docs/stories/004.0-DEV-BRANCH-ANNOTATIONS.story.md
   * @req REQ-BRANCH-DETECTION
   * @req REQ-CONFIGURABLE-SCOPE
   */
  const rule: Rule.RuleModule = {
    meta: {
      type: "problem",
      docs: {
        description: "Require @story and @req annotations on code branches",
        recommended: "error",
      },
      fixable: "code",
      messages: {
        missingAnnotation: "Missing {{missing}} annotation on code branch",
      },
      schema: [ { type: "object", properties: { branchTypes: { type: "array", items: { type: "string" }, uniqueItems: true } }, additionalProperties: false } ],
    },
    create(context) {
      const branchTypesOrListener = validateBranchTypes(context);
      if (!Array.isArray(branchTypesOrListener)) {
        return branchTypesOrListener; // invalid config -> listener reports errors
      }
      const branchTypes = branchTypesOrListener;
      const storyFixCountRef = { count: 0 };
      const handlers: Rule.RuleListener = {};
      branchTypes.forEach((type) => {
        handlers[type] = function branchHandler(node) {
          if (type === "SwitchCase" && (node as any).test == null) {
            return; // ignore default case
          }
          reportMissingAnnotations(context, node, storyFixCountRef);
        };
      });
      return handlers;
    },
  };
  """

2) Branch helper utilities implementing the detailed requirements:
- File: src/utils/branch-annotation-helpers.ts
- Defines default branch types (REQ-SIGNIFICANCE-CRITERIA):
  """
  export const DEFAULT_BRANCH_TYPES = [
    "IfStatement",
    "SwitchCase",
    "TryStatement",
    "CatchClause",
    "ForStatement",
    "ForOfStatement",
    "ForInStatement",
    "WhileStatement",
    "DoWhileStatement",
  ] as const;
  """
- Configuration validation and invalid-config error reporting (REQ-CONFIGURABLE-SCOPE, error handling):
  """
  export function validateBranchTypes(context: Rule.RuleContext): BranchType[] | Rule.RuleListener {
    const options: any = context.options[0] || {};
    if (Array.isArray(options.branchTypes)) {
      function isInvalidType(t: any): boolean {
        return !DEFAULT_BRANCH_TYPES.includes(t as BranchType);
      }
      const invalidTypes = options.branchTypes.filter(isInvalidType);
      if (invalidTypes.length > 0) {
        function ProgramHandler(node: any) {
          function reportInvalidType(t: any) {
            context.report({
              node,
              message: `Value "${t}" should be equal to one of the allowed values: ${DEFAULT_BRANCH_TYPES.join(", ",)}`,
            });
          }
          invalidTypes.forEach(reportInvalidType);
        }
        return { Program: ProgramHandler };
      }
    }
    return Array.isArray(options.branchTypes)
      ? (options.branchTypes as BranchType[])
      : Array.from(DEFAULT_BRANCH_TYPES);
  }
  """
- Comment association and annotation parsing (REQ-COMMENT-ASSOCIATION, REQ-ANNOTATION-PARSING):
  """
  export function gatherBranchCommentText(sourceCode: ReturnType<Rule.RuleContext["getSourceCode"]>, node: any): string {
    if (node.type === "SwitchCase") {
      const lines = sourceCode.lines;
      const startLine = node.loc.start.line;
      let i = startLine - 2;
      const comments: string[] = [];
      while (i >= 0 && /^\s*(\/\/|\/\*)/.test(lines[i])) {
        comments.unshift(lines[i].trim());
        i--;
      }
      return comments.join(" ");
    }
    const comments = sourceCode.getCommentsBefore(node) || [];
    function commentToValue(c: any) { return c.value; }
    return comments.map(commentToValue).join(" ");
  }

  export function reportMissingAnnotations(context: Rule.RuleContext, node: any, storyFixCountRef: { count: number }): void {
    const sourceCode = context.getSourceCode();
    const text = gatherBranchCommentText(sourceCode, node);
    const missingStory = !/@story\b/.test(text);
    const missingReq = !/@req\b/.test(text);
    const indent = sourceCode.lines[node.loc.start.line - 1].match(/^(\s*)/)?.[1] || "";
    const insertPos = sourceCode.getIndexFromLoc({ line: node.loc.start.line, column: 0 });
    const actions = [
      { missing: missingStory, fn: reportMissingStory, args: [context, node, { indent, insertPos, storyFixCountRef }] },
      { missing: missingReq,   fn: reportMissingReq,   args: [context, node, { indent, insertPos, missingStory }] },
    ];
    function processAction(item: { missing: boolean; fn: Function; args: any[] }) {
      if (item.missing) { item.fn(...item.args); }
    }
    actions.forEach(processAction);
  }
  """
- Auto-fix behavior for first missing @story and for @req when only story is present, matching the story’s examples.

3) Tests for the rule (behavior and configuration), including many branch types:
- File: tests/rules/require-branch-annotation.test.ts
- Header ties tests to this story:
  """
  /**
   * Tests for: docs/stories/004.0-DEV-BRANCH-ANNOTATIONS.story.md
   * @story docs/stories/004.0-DEV-BRANCH-ANNOTATIONS.story.md
   * @req REQ-BRANCH-DETECTION - Verify require-branch-annotation rule enforces branch annotations
   */
  """
- Valid cases cover annotated branches for multiple control-flow structures (REQ-BRANCH-DETECTION, REQ-NESTED-HANDLING/integration):
  - IfStatement, ForStatement, WhileStatement, DoWhileStatement, ForOfStatement, ForInStatement
  - Switch with case/default and inline comments, try/finally, catch
  - Custom branchTypes configurations where unlisted types are ignored and listed types require annotations.
- Invalid cases verify detection, messages, and autofix behavior:
  - If with no annotations -> adds `// @story <story-file>.story.md` above and reports missing @story and @req.
  - For loop with only story -> adds `// @req <REQ-ID>` and reports missing @req.
  - While with only @req -> adds story comment and reports missing @story.
  - Switch case without annotations (including blank line before case) -> inserts story comment above case and reports both @story and @req.
  - Try/catch without annotations -> reports missing @story and @req for both try and catch.
  - ForStatement with custom branchTypes enforcing only that type.
- A separate RuleTester run checks invalid configuration:
  """
  ruleTester.run("require-branch-annotation", rule, {
    valid: [],
    invalid: [
      {
        name: "[REQ-CONFIGURABLE-SCOPE] invalid branchTypes option should error schema",
        code: "if (condition) {}",
        options: [{ branchTypes: ["UnknownType"] }],
        errors: [{ message: /should be equal to one of the allowed values/ }],
      },
    ],
  });
  """

4) Unit tests for configuration helper:
- File: tests/utils/branch-annotation-helpers.test.ts
- Validate default and custom branchTypes behavior and error reporting for invalid types.

5) Documentation for the rule:
- File: docs/rules/require-branch-annotation.md
- Explicitly references the story and requirements:
  """
  @story docs/stories/004.0-DEV-BRANCH-ANNOTATIONS.story.md
  @req REQ-BRANCH-DETECTION - Detect significant code branches for traceability annotations
  @req REQ-CONFIGURABLE-SCOPE - Allow configuration of branch types for annotation enforcement
  """
- Describes default/allowed branchTypes, configuration options, correct/incorrect examples, and invalid configuration behavior with the expected error message.

6) Integration in plugin configs:
- File: src/index.ts
- The rule is exported and included in both `recommended` and `strict` configurations:
  """
  const RULE_NAMES = ["require-story-annotation", "require-req-annotation", "require-branch-annotation", ...] as const;
  const configs = {
    recommended: [{ rules: { "traceability/require-branch-annotation": "error", ... } }],
    strict:      [{ rules: { "traceability/require-branch-annotation": "error", ... } }],
  };
  """

7) Test execution evidence:
- Command run in this environment: `npm test -- --ci --bail --runInBand --verbose`.
- Jest executed the full suite (including the branch-annotation rule tests and helper tests) without reporting failures, indicating the implemented behavior matches the tests tied to this story.</evidence>
  <notes>The story docs/stories/004.0-DEV-BRANCH-ANNOTATIONS.story.md specifies an ESLint rule that enforces @story and @req annotations on significant code branches, with configurable scope, clear error messages, robust handling of invalid configuration, and documentation.

Mapping to acceptance criteria:
- Core Functionality: Implemented by `src/rules/require-branch-annotation.ts` plus helpers in `src/utils/branch-annotation-helpers.ts`. The rule inspects configured branch node types (If, SwitchCase, Try/Catch, loops, etc.), collects preceding comments, parses for @story/@req, and reports `missingAnnotation` when they are absent. Autofix behavior for some cases matches the story’s examples. RuleTester tests cover a wide array of branch patterns and ensure missing annotations are detected and fixed correctly.
- Quality Standards: The rule follows ESLint best practices: proper `meta` (type, docs, schema, messages), no side effects in `meta`, separation into helper utilities, and clear configuration schema. Performance is reasonable: it uses per-node visitors with simple string checks and limited comment scanning, suitable for large files, fulfilling REQ-PERFORMANCE-OPTIMIZATION at a pragmatic level.
- Integration: Because listeners are attached by AST node type and do not depend on nesting level, the rule naturally handles nested branches and varied control-flow patterns. Tests demonstrate behavior across many branch forms (loops, switch cases with and without intervening blank lines, try/finally/catch), showing the rule works in realistic, complex code structures.
- User Experience: Error messages are explicit and structured. For branch violations, the `missingAnnotation` message clarifies which annotation ("@story" or "@req") is missing on the affected branch. For invalid `branchTypes` configuration, `validateBranchTypes` reports messages like `Value "InvalidType" should be equal to one of the allowed values: ...`, which aligns with the story’s requirement for configuration error feedback.
- Error Handling: Edge cases are handled gracefully: default switch cases are skipped, invalid configuration returns a safe listener instead of throwing, and behavior when `branchTypes` is omitted falls back to defaults. Comment association logic for SwitchCase uses a bounded backward scan, and for other branches uses ESLint’s `getCommentsBefore`, reasonably covering inline and block comments.
- Documentation: The rule has a dedicated doc file (docs/rules/require-branch-annotation.md) with examples of correct/incorrect usage, configuration options (including `branchTypes`), and behavior on invalid configuration. The rule is also wired into the plugin’s `recommended` and `strict` configs in `src/index.ts`.

All explicit acceptance criteria and listed requirements (REQ-BRANCH-DETECTION, REQ-COMMENT-ASSOCIATION, REQ-ANNOTATION-PARSING, REQ-SIGNIFICANCE-CRITERIA, REQ-NESTED-HANDLING, REQ-CONFIGURABLE-SCOPE, and practical performance considerations) are implemented, tested, and documented, with tests referencing this story and passing in the executed Jest run. Therefore, this story is fully implemented and the assessment status is PASSED.</notes>
</traceability>