<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/006.0-DEV-FILE-VALIDATION.story.md</specification>
  <status>PASSED</status>
  <last_validated>2025-11-21T02:46:29.538Z</last_validated>
  <last_modified>2025-11-20T23:56:53.139Z</last_modified>
  <evidence>Implementation and tests for story 006.0-DEV-FILE-VALIDATION are present and passing.

1) Rule implementation
- File: src/rules/valid-story-reference.ts
- Top-level JSDoc explicitly ties this rule to the story and requirements:
  """
  /**
   * Rule to validate @story annotation references refer to existing story files
   * @story docs/stories/006.0-DEV-FILE-VALIDATION.story.md
   * @req REQ-FILE-EXISTENCE - Validate that story file paths reference existing files
   * @req REQ-PATH-RESOLUTION - Resolve relative paths correctly and enforce configuration
   * @req REQ-SECURITY-VALIDATION - Prevent path traversal and absolute path usage
   */
  """
- Core behavior:
  - Parses annotation lines and extracts the story path:
    """
    function validateStoryPath(opts: { line: string; ... }) {
      const parts = line.split(/\s+/);
      const storyPath = parts[1];
      if (!storyPath) return;
      processStoryPath({ storyPath, ...});
    }
    """
  - Handles annotation comments, scanning for @story lines:
    """
    function handleComment(...) {
      const lines = commentNode.value
        .split(/\r?\n/)
        .map((l: string) => l.replace(/^[^@]*/, "").trim());
      for (const line of lines) {
        if (line.startsWith("@story")) {
          validateStoryPath(...);
        }
      }
    }
    """
  - Path security and extension validation in processStoryPath:
    """
    if (path.isAbsolute(storyPath)) {
      if (!allowAbsolute) {
        context.report({ messageId: "invalidPath", data: { path: storyPath } });
      }
      return;
    }

    if (containsPathTraversal(storyPath)) {
      const full = path.resolve(cwd, path.normalize(storyPath));
      if (!full.startsWith(cwd + path.sep)) {
        context.report({ messageId: "invalidPath", data: { path: storyPath } });
        return;
      }
    }

    if (requireExt && !hasValidExtension(storyPath)) {
      context.report({ messageId: "invalidExtension", data: { path: storyPath } });
      return;
    }

    reportExistenceProblems({ storyPath, ... });
    """
  - Existence and filesystem error reporting:
    """
    function reportExistenceProblems(opts) {
      const result = normalizeStoryPath(storyPath, cwd, storyDirs);
      const existenceResult = result.existence;

      if (!existenceResult || existenceResult.status === "exists") return;

      if (existenceResult.status === "missing") {
        context.report({ messageId: "fileMissing", data: { path: storyPath } });
        return;
      }

      if (existenceResult.status === "fs-error") {
        ... derive errorMessage ...
        context.report({
          messageId: "fileAccessError",
          data: { path: storyPath, error: errorMessage },
        });
      }
    }
    """
  - Rule metadata and clear user-facing messages:
    """
    meta: {
      type: "problem",
      docs: {
        description: "Validate that @story annotations reference existing .story.md files",
        recommended: "error",
      },
      messages: {
        fileMissing: "Story file '{{path}}' not found",
        invalidExtension: "Invalid story file extension for '{{path}}', expected '.story.md'",
        invalidPath: "Invalid story path '{{path}}'",
        fileAccessError:
          "Could not validate story file '{{path}}' due to a filesystem error: {{error}}. Please check file existence and permissions.",
      },
      schema: [{
        type: "object",
        properties: {
          storyDirectories: { type: "array", items: { type: "string" } },
          allowAbsolutePaths: { type: "boolean" },
          requireStoryExtension: { type: "boolean" },
        },
        additionalProperties: false,
      }],
    }
    """
  - Configuration options support configurable directories and behavior:
    """
    const defaultStoryDirs = ["docs/stories", "stories"];
    const opts = context.options[0] as { storyDirectories?: string[]; allowAbsolutePaths?: boolean; requireStoryExtension?: boolean } | undefined;
    const storyDirs = opts?.storyDirectories || defaultStoryDirs;
    const allowAbsolute = opts?.allowAbsolutePaths || false;
    const requireExt = opts?.requireStoryExtension !== false;
    """

2) Path resolution, existence, caching, and security utilities
- File: src/utils/storyReferenceUtils.ts
- Linked to story and requirements:
  """
  /**
   * Utility functions for story path resolution and existence checking.
   * @story docs/stories/006.0-DEV-FILE-VALIDATION.story.md
   * @req REQ-PATH-RESOLUTION
   * @req REQ-FILE-EXISTENCE
   * @req REQ-SECURITY-VALIDATION
   * @req REQ-ERROR-HANDLING
   */
  """
- Candidate path building & path resolution:
  """
  export function buildStoryCandidates(storyPath: string, cwd: string, storyDirs: string[]): string[] {
    const candidates: string[] = [];
    if (storyPath.startsWith("./") || storyPath.startsWith("../")) {
      candidates.push(path.resolve(cwd, storyPath));
    } else {
      candidates.push(path.resolve(cwd, storyPath));
      for (const dir of storyDirs) {
        candidates.push(path.resolve(cwd, dir, path.basename(storyPath)));
      }
    }
    return candidates;
  }
  """
- Caching and safe filesystem access:
  """
  const fileExistStatusCache = new Map<string, StoryPathCheckResult>();

  function checkSingleCandidate(candidate: string): StoryPathCheckResult {
    const cached = fileExistStatusCache.get(candidate);
    if (cached) return cached;

    let result: StoryPathCheckResult;
    try {
      const exists = fs.existsSync(candidate);
      if (!exists) {
        result = { path: candidate, status: "missing" };
      } else {
        const stat = fs.statSync(candidate);
        if (stat.isFile()) {
          result = { path: candidate, status: "exists" };
        } else {
          result = { path: candidate, status: "missing" };
        }
      }
    } catch (error) {
      result = { path: candidate, status: "fs-error", error };
    }
    fileExistStatusCache.set(candidate, result);
    return result;
  }
  """
- Aggregated existence with explicit fs-error state:
  """
  export function getStoryExistence(candidates: string[]): StoryExistenceResult {
    let firstFsError: StoryPathCheckResult | undefined;
    for (const candidate of candidates) {
      const res = checkSingleCandidate(candidate);
      if (res.status === "exists") {
        return { candidates, status: "exists", matchedPath: res.path };
      }
      if (res.status === "fs-error" && !firstFsError) {
        firstFsError = res;
      }
    }
    if (firstFsError) {
      return { candidates, status: "fs-error", error: firstFsError.error };
    }
    return { candidates, status: "missing" };
  }

  export function storyExists(paths: string[]): boolean {
    const result = getStoryExistence(paths);
    return result.status === "exists";
  }

  export function normalizeStoryPath(storyPath: string, cwd: string, storyDirs: string[]) {
    const candidates = buildStoryCandidates(storyPath, cwd, storyDirs);
    const existence = getStoryExistence(candidates);
    const exists = existence.status === "exists";
    return { candidates, exists, existence };
  }
  """
- Security and extension helpers:
  """
  export function containsPathTraversal(p: string): boolean {
    const normalized = path.normalize(p);
    return normalized.split(path.sep).includes("..");
  }

  export function hasValidExtension(p: string): boolean {
    return p.endsWith(".story.md");
  }
  """

3) Tests for this story and rule behavior
- File: tests/rules/valid-story-reference.test.ts
- Header explicitly references the story and requirements:
  """
  /**
   * Tests for: docs/stories/006.0-DEV-FILE-VALIDATION.story.md
   * @story docs/stories/006.0-DEV-FILE-VALIDATION.story.md
   * @req REQ-FILE-EXISTENCE - Verify valid-story-reference rule enforces existing .story.md files
   */
  """
- Core valid/invalid scenarios exercising file existence, extensions, and security:
  """
  ruleTester.run("valid-story-reference", rule, {
    valid: [
      {
        name: "[REQ-FILE-EXISTENCE] valid story file reference",
        code: `// @story docs/stories/001.0-DEV-PLUGIN-SETUP.story.md`,
      },
      {
        name: "[REQ-EXTENSION] valid .story.md extension",
        code: `// @story docs/stories/002.0-DEV-ESLINT-CONFIG.story.md`,
      },
      {
        name: "[REQ-PATH-RESOLUTION] valid relative path with ./ prefix",
        code: `// @story ./docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md`,
      },
    ],
    invalid: [
      {
        name: "[REQ-PATH-RESOLUTION] missing file",
        code: `// @story docs/stories/missing-file.story.md`,
        errors: [{ messageId: "fileMissing", data: { path: "docs/stories/missing-file.story.md" } }],
      },
      {
        name: "[REQ-EXTENSION] invalid extension",
        code: `// @story docs/stories/001.0-DEV-PLUGIN-SETUP.md`,
        errors: [{ messageId: "invalidExtension", data: { path: "docs/stories/001.0-DEV-PLUGIN-SETUP.md" } }],
      },
      {
        name: "[REQ-PATH-SECURITY] path traversal",
        code: `// @story ../outside.story.md`,
        errors: [{ messageId: "invalidPath", data: { path: "../outside.story.md" } }],
      },
      {
        name: "[REQ-ABSOLUTE-PATH] absolute path not allowed",
        code: `// @story /etc/passwd.story.md`,
        errors: [{ messageId: "invalidPath", data: { path: "/etc/passwd.story.md" } }],
      },
    ],
  });
  """
- Additional tests for error-handling behavior around filesystem errors:
  - Verify storyExists swallows fs errors and returns false (no throw) for permission and I/O errors.
  - Verify the rule reports "fileAccessError" (with EACCES/EIO in the message data) when fs.existsSync or fs.statSync throw.
  """
  it("[REQ-ERROR-HANDLING] storyExists returns false when fs throws", () => { ... });
  it("[REQ-ERROR-HANDLING] storyExists returns false when fs.statSync throws EIO and existsSync is true", () => { ... });
  it("[REQ-ERROR-HANDLING] rule reports fileAccessError when fs.statSync throws and existsSync is true", () => { ... });
  it("[REQ-ERROR-HANDLING] rule reports fileAccessError when fs throws", () => { ... });
  """

4) Rule integration with plugin and configuration
- File: src/index.ts
- Rule name is included in the plugin's exported RULE_NAMES and configs:
  """
  const RULE_NAMES = [
    "require-story-annotation",
    "require-req-annotation",
    "require-branch-annotation",
    "valid-annotation-format",
    "valid-story-reference",
    "valid-req-reference",
  ] as const;

  const configs = {
    recommended: [
      {
        plugins: { traceability: {} },
        rules: {
          "traceability/valid-story-reference": "error",
          ...
        },
      },
    ],
    strict: [
      {
        plugins: { traceability: {} },
        rules: {
          "traceability/valid-story-reference": "error",
          ...
        },
      },
    ],
  };
  """
- The story itself shows example configuration that matches the rule options and naming ("traceability/valid-story-reference"), and that file docs/stories/006.0-DEV-FILE-VALIDATION.story.md exists and includes path resolution rules and examples.

5) Filesystem and project structure
- Story files used in tests as "existing" do exist:
  - docs/stories/001.0-DEV-PLUGIN-SETUP.story.md
  - docs/stories/002.0-DEV-ESLINT-CONFIG.story.md
  - docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md
- docs/stories directory listing confirms the story under assessment and related stories:
  - 001.0-DEV-PLUGIN-SETUP.story.md
  - 002.0-DEV-ESLINT-CONFIG.story.md
  - 003.0-DEV-FUNCTION-ANNOTATIONS.story.md
  - 004.0-DEV-BRANCH-ANNOTATIONS.story.md
  - 005.0-DEV-ANNOTATION-VALIDATION.story.md
  - 006.0-DEV-FILE-VALIDATION.story.md
  - 007.0-DEV-ERROR-REPORTING.story.md
  - ...

6) Test execution
- Command executed:
  - npm test -- --runInBand --verbose
- Reported output shows Jest running in CI + verbose mode and completing without error; the command did not fail, which indicates all Jest tests (including valid-story-reference tests) passed successfully:
  """
  > eslint-plugin-traceability@1.0.5 test
  > jest --ci --bail --runInBand --verbose

  [console.debug output from other rules...]
  """
- No non-zero exit or failure message was returned by the test command.
</evidence>
  <notes>Story 006.0-DEV-FILE-VALIDATION is fully implemented:
- Core functionality is present: the valid-story-reference ESLint rule parses @story annotations, checks for valid .story.md extensions, resolves paths using cwd and configurable directories, and validates file existence via cached filesystem checks.
- Security and project-boundary concerns are handled: absolute paths are rejected by default, and '../' traversal that escapes the cwd is detected and reported as invalid.
- Error handling is robust: all filesystem interactions are wrapped in try/catch, surfaced via a dedicated fs-error status, and reported through a clear fileAccessError message; dedicated tests simulate EACCES and EIO conditions to confirm no uncaught exceptions and correct diagnostics.
- User experience criteria are met: message templates clearly indicate the failing path and whether the issue is missing file, invalid extension, invalid path, or filesystem access error.
- Integration is complete: the rule is exported by the plugin index, included in both recommended and strict configs, and has focused tests via ESLint RuleTester plus helper-based tests for low-level error conditions.
- Documentation for path resolution, security, configuration, and examples is provided directly in docs/stories/006.0-DEV-FILE-VALIDATION.story.md, aligning with the implemented rule and utilities.

Given the concrete implementation and passing tests tied directly to this story and its requirements, all acceptance criteria for this story are satisfied.</notes>
</traceability>