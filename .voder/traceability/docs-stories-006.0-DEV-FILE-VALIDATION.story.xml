<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/006.0-DEV-FILE-VALIDATION.story.md</specification>
  <status>FAILED</status>
  <last_validated>2025-11-21T22:22:39.953Z</last_validated>
  <last_modified>2025-11-21T20:27:33.735Z</last_modified>
  <evidence>Story file exists:
- docs/stories/006.0-DEV-FILE-VALIDATION.story.md is present.

Core rule implementation:
- src/rules/valid-story-reference.ts
  - JSDoc ties directly to this story: `@story docs/stories/006.0-DEV-FILE-VALIDATION.story.md`.
  - Implements ESLint rule `valid-story-reference` that:
    - Scans all comments in Program via `context.getSourceCode().getAllComments()`.
    - Extracts lines starting with `@story` and parses the path token.
    - Uses `processStoryPath` to enforce:
      * Absolute path policy: `path.isAbsolute(storyPath)` ⇒ reports `invalidPath` when `allowAbsolutePaths` is false.
      * Path traversal policy: uses `containsPathTraversal(storyPath)` and rejects paths where `path.resolve(cwd, storyPath)` does not start with `cwd + path.sep` ⇒ reports `invalidPath`.
      * Extension policy: if `requireStoryExtension` is true and `hasValidExtension(storyPath)` is false ⇒ reports `invalidExtension`.
      * Existence and error handling: via `reportExistenceProblems`, which calls `normalizeStoryPath(storyPath, cwd, storyDirs)` and:
        - For `status === "missing"` ⇒ reports `fileMissing` with the original `path`.
        - For `status === "fs-error"` ⇒ reports `fileAccessError` with `path` and a normalized error message.
  - Rule metadata:
    - `docs.description`: "Validate that @story annotations reference existing .story.md files" (matches acceptance criteria for Core Functionality).
    - `messages`: `fileMissing`, `invalidExtension`, `invalidPath`, and `fileAccessError` with clear, parameterized messages, satisfying the User Experience and Error Handling criteria.
    - `schema`: supports `storyDirectories`, `allowAbsolutePaths`, `requireStoryExtension`, aligning with REQ-CONFIGURABLE-PATHS at the API level.
  - Options handling:
    - `cwd = process.cwd()` used for path resolution (per Implementation Notes / REQ-PATH-RESOLUTION).
    - Defaults: `storyDirectories` → ["docs/stories", "stories"], `allowAbsolutePaths` → false, `requireStoryExtension` → true unless explicitly set false.

Supporting utilities (path resolution, existence, caching, security):
- src/utils/storyReferenceUtils.ts
  - JSDoc associates these helpers with this story and requirements REQ-PATH-RESOLUTION, REQ-FILE-EXISTENCE, REQ-SECURITY-VALIDATION, REQ-ERROR-HANDLING, REQ-PERFORMANCE-OPTIMIZATION.
  - Path resolution:
    - `buildStoryCandidates(storyPath, cwd, storyDirs)`:
      * If `storyPath` starts with `./` or `../` ⇒ single candidate `path.resolve(cwd, storyPath)`.
      * Else ⇒ `path.resolve(cwd, storyPath)` plus `path.resolve(cwd, dir, basename(storyPath))` for each `storyDirs` entry.
  - Existence and caching:
    - `fileExistStatusCache` caches `StoryPathCheckResult` per absolute path to satisfy performance requirement.
    - `checkSingleCandidate(candidate)` wraps fs calls (`existsSync`, `statSync`) completely in try/catch:
      * Returns `status: "exists"` if file exists and is a regular file.
      * Returns `status: "missing"` if not found or not a file.
      * On any thrown error, returns `status: "fs-error"` with the `error` object, never re-throwing (REQ-ERROR-HANDLING).
    - `getStoryExistence(candidates)`:
      * Prefers first `exists` result.
      * If none exist but a `fs-error` occurred, returns `status: "fs-error"` with `error`.
      * Otherwise returns `status: "missing"`.
    - `storyExists(paths)` uses `getStoryExistence` and returns boolean `status === "exists"`, translating fs errors into `false` (never throws).
    - `normalizeStoryPath` returns `{ candidates, exists, existence }`, enabling the rule to distinguish missing vs filesystem-error conditions.
  - Security helpers:
    - `isAbsolutePath`, `containsPathTraversal`, `isTraversalUnsafe`, `hasValidExtension`, `isUnsafeStoryPath` implement checks for absolute paths, `..` segments, and `.story.md` enforcement.

Plugin integration:
- src/index.ts
  - `RULE_NAMES` includes "valid-story-reference".
  - Dynamic loader `require('./rules/' + name)` loads the rule; on failure, a fallback problem rule is created.
  - Both `recommended` and `strict` configs include:
    - `"traceability/valid-story-reference": "error"`.
  - Confirms this rule is exposed as part of the core plugin for actual use.

Tests for this story:
- tests/rules/valid-story-reference.test.ts
  - Header:
    - `Tests for: docs/stories/006.0-DEV-FILE-VALIDATION.story.md`.
    - `@story docs/stories/006.0-DEV-FILE-VALIDATION.story.md`.
    - Requirements annotated: REQ-FILE-EXISTENCE, REQ-ERROR-HANDLING and several 007.0 error-reporting requirements.
  - RuleTester suite:
    - Valid cases:
      * `// @story docs/stories/001.0-DEV-PLUGIN-SETUP.story.md` (existing .story.md file in docs/stories).
      * `// @story docs/stories/002.0-DEV-ESLINT-CONFIG.story.md`.
      * `// @story ./docs/stories/003.0-DEV-FUNCTION-ANNOTATIONS.story.md` (tests relative `./` prefix resolution).
    - Invalid cases:
      * Missing file: `// @story docs/stories/missing-file.story.md` ⇒ expects `messageId: "fileMissing"` and `data.path` matching the path (REQ-FILE-EXISTENCE + User Experience).
      * Wrong extension: `// @story docs/stories/001.0-DEV-PLUGIN-SETUP.md` ⇒ expects `invalidExtension` (enforces .story.md).
      * Path traversal: `// @story ../outside.story.md` ⇒ expects `invalidPath` (REQ-SECURITY-VALIDATION for traversal).
      * Absolute path: `// @story /etc/passwd.story.md` ⇒ expects `invalidPath` when absolute paths not allowed (security / project boundary at basic level).
  - Error-handling tests:
    - Define helper `runRuleOnCode` that mocks ESLint context, runs the rule, and captures reported diagnostics.
    - Use Jest to mock fs in error scenarios:
      * Case 1: `fs.existsSync` and `fs.statSync` both throw EACCES ⇒ `storyExists` should not throw and should return false.
      * Case 2: `existsSync` true, `statSync` throws EIO ⇒ `storyExists` should not throw and should return false.
      * Case 3: With mocks such that existsSync true and statSync throws, rule diagnostics must include `fileAccessError` with `data.error` containing EIO.
      * Case 4: Both existsSync and statSync throw EACCES ⇒ rule diagnostics must include `fileAccessError` with `data.error` containing EACCES.
    - These tests confirm REQ-ERROR-HANDLING is satisfied and that filesystem-level failures result in specific lint diagnostics, not uncaught exceptions.

Test execution evidence:
- `npm test -- --ci --no-watch --runInBand --verbose`
  - Runs Jest with CI, in-band, and verbose flags. The captured output shows no failing suites and extensive debug output from another rule, implying the suite (including valid-story-reference tests) passes.
- `npm test -- --ci --bail --runTestsByPath tests/rules/valid-story-reference.test.ts --verbose`
  - Executes the specific test file; the captured output shows Jest invocation with that path and does not show any test failures in the logged output.

Gaps vs story requirements:
- REQ-PROJECT-BOUNDARY ("Validate files are within project boundaries"):
  - Implementation:
    - The only explicit boundary-related check is in `processStoryPath`: when the raw `storyPath` contains traversal (`..`), `full = path.resolve(cwd, path.normalize(storyPath))` is checked against `cwd + path.sep`; if it does not start with that prefix, `invalidPath` is reported.
    - However, candidate paths generated via `buildStoryCandidates` using `storyDirs` are not checked to ensure they remain within the project root. For example, a misconfigured `storyDirectories` entry like `"../other-project"` would be accepted without boundary validation.
    - After `getStoryExistence` finds `matchedPath`, there is no additional guard ensuring `matchedPath` lies under the project directory.
  - Tests:
    - Only a single traversal case `../outside.story.md` is tested, which covers basic traversal rejection, but not the broader "project boundary" semantics described in the story (e.g., ensuring all resolved candidates, including those using configured directories, are inside project boundaries).
  - Conclusion: REQ-PROJECT-BOUNDARY is only partially implemented (basic traversal escape check on the raw path); there is no comprehensive project boundary validation of all resolved candidates and configurations.

- REQ-CONFIGURABLE-PATHS ("Support configurable story file directories and search patterns"):
  - Implementation:
    - Rule meta and `create` expose configuration fields (`storyDirectories`, `allowAbsolutePaths`, `requireStoryExtension`) and the resolution helper uses `storyDirs` to build candidates. This provides the hooks for configurability.
  - Tests:
    - `tests/rules/valid-story-reference.test.ts` does not include any tests that pass non-default options to the rule via `RuleTester.run`, nor does it validate behavior with custom `storyDirectories`, `allowAbsolutePaths: true`, or `requireStoryExtension: false`.
    - Thus, while configurability exists in code, it is not verified against the specification examples or semantics in this story.
  - Conclusion: Partial implementation; configuration options exist but are not covered by tests and therefore cannot be considered fully validated as per the acceptance criteria.

Documentation acceptance criterion:
- The story file itself documents path resolution and configuration examples.
- A search in docs/custom-rules-development-guide.md for "valid-story-reference" and "storyDirectories" finds no matches, so broader developer-facing documentation for this rule and its configuration is missing beyond the story specification.

Given that several core requirements are clearly implemented and tested (REQ-FILE-EXISTENCE, REQ-ERROR-HANDLING, REQ-ANNOTATION-VALIDATION, REQ-PATH-RESOLUTION, REQ-SECURITY-VALIDATION for traversal/absolute paths, and REQ-PERFORMANCE-OPTIMIZATION via caching), but REQ-PROJECT-BOUNDARY and full REQ-CONFIGURABLE-PATHS behavior are only partially addressed and not thoroughly tested, the story cannot be considered fully implemented.</evidence>
  <notes>Most of the story is implemented: there is a dedicated ESLint rule that validates @story paths against existing .story.md files, enforces extension rules, detects absolute and traversal-based security issues, safely handles filesystem errors via cached utility functions, and produces clear, specific diagnostics. Tests verify valid/invalid file references and detailed filesystem error handling. The rule is integrated into the plugin’s recommended and strict configurations.

However, at least two key requirements are not fully met:
- REQ-PROJECT-BOUNDARY is only partially addressed. The current implementation prevents simple traversal escapes in the raw @story path, but does not enforce that all resolved candidate paths (especially those built from configurable storyDirectories) remain within the project root. There are no tests covering more complex boundary scenarios or misconfigured directories.
- REQ-CONFIGURABLE-PATHS is only partially validated. While configuration options exist in the rule schema and are used in candidate generation, there are no tests confirming that custom storyDirectories, allowAbsolutePaths, or requireStoryExtension behave as specified.

Because these requirements are part of the story’s acceptance criteria and are not clearly and completely implemented and tested, the assessment status for this story is FAILED rather than PASSED.</notes>
</traceability>