<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/006.0-DEV-FILE-VALIDATION.story.md</specification>
  <status>PASSED</status>
  <last_validated>2025-11-21T01:26:39.619Z</last_validated>
  <last_modified>2025-11-20T23:56:53.139Z</last_modified>
  <evidence>Key implementation and tests tied directly to docs/stories/006.0-DEV-FILE-VALIDATION.story.md:

1) Rule implementation
- File: src/rules/valid-story-reference.ts
- JSDoc:
  - "Rule to validate @story annotation references refer to existing story files"
  - @story docs/stories/006.0-DEV-FILE-VALIDATION.story.md
  - @req REQ-FILE-EXISTENCE, REQ-PATH-RESOLUTION, REQ-SECURITY-VALIDATION, REQ-ERROR-HANDLING, REQ-ANNOTATION-VALIDATION
- Annotation parsing (REQ-ANNOTATION-VALIDATION):
  - handleComment(...):
    - Reads all comments via context.getSourceCode().getAllComments().
    - Splits commentNode.value by line breaks, then maps lines with:
      .map((l: string) => l.replace(/^[^@]*/, "").trim());
    - For each line starting with "@story" calls validateStoryPath(...).
  - validateStoryPath(...):
    - Splits the annotation line on whitespace and extracts the path from parts[1].
    - Delegates to processStoryPath(...) with cwd, storyDirs, allowAbsolute, requireExt.

- Path, security, and extension validation (REQ-PATH-RESOLUTION, REQ-SECURITY-VALIDATION, REQ-PROJECT-BOUNDARY):
  - Uses const cwd = process.cwd() and default storyDirs = ["docs/stories", "stories"].
  - Absolute paths:
    - if (path.isAbsolute(storyPath)) { if !allowAbsolute → context.report({ messageId: "invalidPath", data: { path: storyPath } }); return; }
  - Path traversal / project boundary:
    - if (containsPathTraversal(storyPath)) {
        const full = path.resolve(cwd, path.normalize(storyPath));
        if (!full.startsWith(cwd + path.sep)) report invalidPath.
      }
    - This prevents "../outside-project.story.md" and enforces the project boundary.
  - Extension enforcement:
    - if (requireExt && !hasValidExtension(storyPath)) → report messageId: "invalidExtension" with the offending path.

- File existence and filesystem error handling (REQ-FILE-EXISTENCE, REQ-ERROR-HANDLING):
  - reportExistenceProblems(...):
    - const result = normalizeStoryPath(storyPath, cwd, storyDirs);
    - const existenceResult = result.existence;
    - If status === "missing" → context.report({ messageId: "fileMissing", data: { path: storyPath } }).
    - If status === "fs-error":
      - Builds errorMessage from existenceResult.error (handles Error, null/undefined, or primitive) and reports:
        context.report({ messageId: "fileAccessError", data: { path: storyPath, error: errorMessage } }).

- User-facing messages (User Experience criterion):
  - meta.messages:
    - fileMissing: "Story file '{{path}}' not found".
    - invalidExtension: "Invalid story file extension for '{{path}}', expected '.story.md'".
    - invalidPath: "Invalid story path '{{path}}'".
    - fileAccessError: "Could not validate story file '{{path}}' due to a filesystem error: {{error}}. Please check file existence and permissions.".
  - These messages clearly indicate what is wrong and how to fix it.

- Configuration / schema (REQ-CONFIGURABLE-PATHS):
  - meta.schema[0].properties:
    - storyDirectories: { type: "array", items: { type: "string" } }.
    - allowAbsolutePaths: { type: "boolean" }.
    - requireStoryExtension: { type: "boolean" }.
  - create(context):
    - Reads options[0] and applies defaults:
      - storyDirs = opts?.storyDirectories || ["docs/stories", "stories"].
      - allowAbsolute = opts?.allowAbsolutePaths || false.
      - requireExt = opts?.requireStoryExtension !== false (true by default).
    - Program() visitor uses these values to drive validation, matching the configuration example in the story.

2) Supporting utilities
- File: src/utils/storyReferenceUtils.ts
- JSDoc:
  - @story docs/stories/006.0-DEV-FILE-VALIDATION.story.md
  - @req REQ-PATH-RESOLUTION, REQ-FILE-EXISTENCE, REQ-SECURITY-VALIDATION, REQ-ERROR-HANDLING, REQ-PERFORMANCE-OPTIMIZATION

- Path resolution (REQ-PATH-RESOLUTION):
  - buildStoryCandidates(storyPath, cwd, storyDirs):
    - If storyPath starts with "./" or "../": candidates.push(path.resolve(cwd, storyPath)).
    - Else:
      - candidates.push(path.resolve(cwd, storyPath)).
      - For each dir in storyDirs: candidates.push(path.resolve(cwd, dir, path.basename(storyPath))).
    - This matches the spec: resolve relative paths, and search configured story directories under project root.

- Performance and caching (REQ-PERFORMANCE-OPTIMIZATION):
  - fileExistStatusCache: Map<string, StoryPathCheckResult>.
  - checkSingleCandidate(candidate):
    - Looks up candidate in cache; if found, returns cached result.
    - After checking fs.existsSync/statSync (or catching errors), stores result in cache.
    - Prevents repeated filesystem calls for the same absolute path in a single run.

- File existence and error handling (REQ-FILE-EXISTENCE, REQ-ERROR-HANDLING):
  - checkSingleCandidate(candidate):
    - try {
        if !fs.existsSync(candidate) → status "missing".
        else {
          const stat = fs.statSync(candidate);
          if stat.isFile() → status "exists"; else → status "missing".
      } catch (error) {
        result = { path: candidate, status: "fs-error", error };
      }
  - getStoryExistence(candidates):
    - Iterates candidates, for each calls checkSingleCandidate:
      - First "exists" → returns { status: "exists", matchedPath }.
      - Tracks first "fs-error".
    - If no "exists" but there was an "fs-error" → returns status "fs-error" with error.
    - If only "missing" → returns status "missing".
  - storyExists(paths: string[]):
    - Calls getStoryExistence(paths) and returns result.status === "exists"; never throws.
  - normalizeStoryPath(storyPath, cwd, storyDirs):
    - Builds candidates, gets existence, and returns { candidates, exists, existence }.

- Security and project boundary (REQ-SECURITY-VALIDATION, REQ-PROJECT-BOUNDARY):
  - isAbsolutePath(p): wraps path.isAbsolute.
  - containsPathTraversal(p): path.normalize(p), then checks for ".." segment.
  - isTraversalUnsafe(p): combines isAbsolutePath and containsPathTraversal.
  - hasValidExtension(p): requires '.story.md'.
  - isUnsafeStoryPath(p): combines traversal/absolute and extension rules.
  - Combined with valid-story-reference.ts (absolute and traversal checks + cwd containment) this enforces project boundary and blocks traversal.

3) Plugin integration
- File: src/index.ts
- Exports rule and includes it in configurations:
  - RULE_NAMES includes "valid-story-reference".
  - Dynamic loader: require(`./rules/${name}`) and assigns to rules[name].
  - configs.recommended and configs.strict both enable:
    - "traceability/valid-story-reference": "error".
  - Ensures integration with other traceability rules (require-story-annotation, valid-annotation-format, etc.), satisfying the story’s "Integration" criterion.

4) Tests linked to the story
- File: tests/rules/valid-story-reference.test.ts
- Header:
  - "Tests for: docs/stories/006.0-DEV-FILE-VALIDATION.story.md"
  - @story docs/stories/006.0-DEV-FILE-VALIDATION.story.md
  - @req REQ-FILE-EXISTENCE

- RuleTester tests – core validation behavior:
  - Valid cases:
    - "[REQ-FILE-EXISTENCE] valid story file reference":
      - code: `// @story docs/stories/001.0-DEV-PLUGIN-SETUP.story.md`.
      - docs/stories/001.0-DEV-PLUGIN-SETUP.story.md is present in docs/stories/, so this exercises the positive path where the rule must allow an existing .story.md file.
    - "[REQ-EXTENSION] valid .story.md extension": valid .story.md reference.
    - "[REQ-PATH-RESOLUTION] valid relative path with ./ prefix": tests resolution of './docs/stories/...' form.
  - Invalid cases:
    - Missing file (REQ-FILE-EXISTENCE):
      - code: `// @story docs/stories/missing-file.story.md`.
      - expects error: { messageId: "fileMissing", data: { path: "docs/stories/missing-file.story.md" } }.
    - Invalid extension:
      - code: `// @story docs/stories/001.0-DEV-PLUGIN-SETUP.md`.
      - expects error: { messageId: "invalidExtension", data: { path: "...SETUP.md" } }.
    - Path traversal:
      - code: `// @story ../outside.story.md`.
      - expects error: { messageId: "invalidPath", data: { path: "../outside.story.md" } }.
    - Absolute path:
      - code: `// @story /etc/passwd.story.md`.
      - expects error: { messageId: "invalidPath", data: { path: "/etc/passwd.story.md" } }.
  - These tests validate existence, extension, security (traversal, absolute paths), and clear error messages.

- Dedicated error-handling tests (REQ-ERROR-HANDLING):
  - Helper runRuleOnCode(...) executes the rule manually and collects diagnostics.
  - Uses fs mocks with jest.spyOn(fs, ...):
    - "[REQ-ERROR-HANDLING] storyExists returns false when fs throws":
      - existsSync and statSync both throw EACCES; storyExists([...]) does not throw and returns false.
    - "[REQ-ERROR-HANDLING] storyExists returns false when fs.statSync throws EIO and existsSync is true":
      - existsSync returns true, statSync throws EIO; storyExists(...) does not throw and returns false.
    - "[REQ-ERROR-HANDLING] rule reports fileAccessError when fs.statSync throws and existsSync is true":
      - existsSync → true, statSync → throw EIO.
      - runRuleOnCode(`// @story docs/stories/fs-stat-io-error.story.md`) collects diagnostics.
      - Asserts at least one diagnostic with messageId === "fileAccessError" and error data matching /EIO/.
    - "[REQ-ERROR-HANDLING] rule reports fileAccessError when fs throws":
      - Both existsSync and statSync throw EACCES.
      - runRuleOnCode(`// @story docs/stories/fs-error.story.md`) must produce a 'fileAccessError' diagnostic whose error field contains 'EACCES'.
  - Confirms filesystem permission and I/O problems are surfaced as dedicated diagnostics, not thrown exceptions.

5) Test execution evidence
- Command run by tools: npm test -- --runInBand --verbose
  - package.json: "test": "jest --ci --bail" → executed as: jest --ci --bail --runInBand --verbose.
  - Tool output shows Jest running in CI + verbose mode with no non-zero exit code or 'Command failed' message for this run, indicating all tests passed, including tests/rules/valid-story-reference.test.ts.

6) Documentation and examples
- Story file itself: docs/stories/006.0-DEV-FILE-VALIDATION.story.md
  - Lists requirements: REQ-FILE-EXISTENCE, REQ-ERROR-HANDLING, REQ-ANNOTATION-VALIDATION, REQ-PATH-RESOLUTION, REQ-SECURITY-VALIDATION, REQ-PERFORMANCE-OPTIMIZATION, REQ-PROJECT-BOUNDARY, REQ-CONFIGURABLE-PATHS.
  - Provides path examples:
    - Valid: docs/stories/001.0-DEV-EXAMPLE.story.md, stories/feature.story.md, ./local-story.story.md.
    - Invalid: ../outside-project.story.md, docs/stories/missing.story.md, wrong extension, absolute paths.
  - Provides a configuration snippet using "traceability/valid-story-reference" with storyDirectories, allowAbsolutePaths, requireStoryExtension, which maps directly to the rule’s schema and option handling.</evidence>
  <notes>All acceptance criteria for docs/stories/006.0-DEV-FILE-VALIDATION.story.md are satisfied:

- Core Functionality (validates @story file paths reference existing .story.md files):
  - The valid-story-reference rule extracts @story paths, resolves candidates using cwd and configurable storyDirectories, checks existence and extension via storyReferenceUtils, and reports missing files ('fileMissing') and invalid extensions ('invalidExtension'). Tests cover both valid and invalid examples.

- Quality Standards (ESLint best practices and safe filesystem handling):
  - Rule is structured with meta/create as recommended by ESLint and uses RuleTester-based tests.
  - All filesystem I/O (fs.existsSync/statSync) is confined to storyReferenceUtils, wrapped in try/catch, and never throws; errors are converted to 'fs-error' status and then to 'fileAccessError' diagnostics.
  - A cache (fileExistStatusCache) avoids redundant filesystem calls.

- Integration (works with annotations validated by previous stories):
  - src/index.ts exports the rule and enables it in recommended/strict configs along with annotation-format and annotation-presence rules, ensuring this file-check rule runs on annotations already validated for format and presence.

- User Experience (clear error messages):
  - meta.messages in valid-story-reference.ts clearly distinguish missing files, invalid extensions, invalid paths, and filesystem access errors, including guidance to check file existence and permissions.

- Error Handling (filesystem permissions, network drives, edge cases):
  - storyReferenceUtils’s getStoryExistence/checkSingleCandidate never throw and classify errors as 'fs-error'.
  - reportExistenceProblems maps 'fs-error' to a dedicated 'fileAccessError' message with embedded error detail.
  - Jest tests simulate EACCES and EIO errors to confirm stories are not misclassified as missing and that diagnostics use the 'fileAccessError' message.

- Documentation (rules and configuration examples):
  - The story itself documents path resolution rules, valid/invalid examples, and the exact rule configuration, which matches the implemented schema and behavior.

Additional technical requirements are also covered:
- REQ-ANNOTATION-VALIDATION: handleComment/validateStoryPath properly parse @story lines from comments.
- REQ-PATH-RESOLUTION: buildStoryCandidates/normalizeStoryPath resolve paths from project root and configured directories.
- REQ-SECURITY-VALIDATION & REQ-PROJECT-BOUNDARY: absolute and traversal paths are detected and rejected when they escape cwd; tests cover traversal and absolute path scenarios.
- REQ-PERFORMANCE-OPTIMIZATION: caching via fileExistStatusCache minimizes redundant fs checks.
- REQ-CONFIGURABLE-PATHS: meta.schema and option handling implement storyDirectories, allowAbsolutePaths, and requireStoryExtension exactly as described.

All related tests pass under Jest, providing strong evidence that the implementation of this story is complete and functioning as specified.</notes>
</traceability>