<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/010.0-DEV-DEEP-VALIDATION.story.md</specification>
  <status>PASSED</status>
  <last_validated>2025-11-21T08:33:00.887Z</last_validated>
  <last_modified>2025-11-19T04:17:32.853Z</last_modified>
  <evidence>Rule implementation exists and is explicitly tied to this story:
  - File: src/rules/valid-req-reference.ts
  - Header JSDoc:
    /**
     * Rule to validate @req annotation references refer to existing requirements in story files
     * @story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
     * @req REQ-DEEP-PARSE - Parse comments and extract story/requirement metadata
     * @req REQ-DEEP-MATCH - Match @req annotations to story file requirements
     * @req REQ-DEEP-CACHE - Cache requirement IDs per story file for efficient validation
     * @req REQ-DEEP-PATH - Validate and resolve story file paths safely
     */,Core deep-validation behavior implemented:
  - Function validateReqLine(...) in src/rules/valid-req-reference.ts:
    - Extracts reqId from a @req line.
    - Validates storyPath (rejects path traversal '..' and absolute paths via path.isAbsolute):
      if (storyPath.includes("..") || path.isAbsolute(storyPath)) { context.report({ messageId: "invalidPath" ... }) }
    - Resolves story path relative to cwd and ensures it stays under cwd:
      const resolvedStoryPath = path.resolve(cwd, storyPath);
      if (!resolvedStoryPath.startsWith(cwd + path.sep) && resolvedStoryPath !== cwd) { report invalidPath }
    - Caches parsed requirements per story file:
      const reqCache = new Map<string, Set<string>>();
      if (!reqCache.has(resolvedStoryPath)) { ... readFileSync(...) ... regex /REQ-[A-Z0-9-]+/g ... reqCache.set(resolvedStoryPath, found); }
    - Checks existence of the referenced requirement ID:
      const reqSet = reqCache.get(resolvedStoryPath)!;
      if (!reqSet.has(reqId)) {
        context.report({ messageId: "reqMissing", data: { reqId, storyPath } });
      },Requirement parsing and matching across comments:
  - extractStoryPath(comment): parses JSDoc-style comment lines to find '@story <path>'.
  - handleAnnotationLine(...):
    - If line starts with '@story', updates storyPath using extractStoryPath.
    - If line starts with '@req', calls validateReqLine to perform deep validation.
  - handleComment(...): iterates all lines of a comment block, calling handleAnnotationLine to process both @story and @req in sequence and maintain current storyPath.
  - programListener(context):
    - Creates a shared reqCache Map and rawStoryPath variable.
    - Program visitor gets all comments via sourceCode.getAllComments(), then for each comment calls handleComment, reusing storyPath and cache across comments in the file.,ESLint rule wiring and messages (user experience + integration):
  - Default export in src/rules/valid-req-reference.ts:
    export default {
      meta: {
        type: "problem",
        docs: {
          description:
            "Validate that @req annotations reference existing requirements in referenced story files",
          recommended: "error",
        },
        messages: {
          reqMissing: "Requirement '{{reqId}}' not found in '{{storyPath}}'",
          invalidPath: "Invalid story path '{{storyPath}}'",
        },
        schema: [],
      },
      create(context) {
        return { Program: programListener(context) };
      },
    } as Rule.RuleModule;
  - Plugin integration in src/index.ts:
    - RULE_NAMES includes "valid-req-reference".
    - configs.recommended and configs.strict both enable:
      "traceability/valid-req-reference": "error".,Tests explicitly tied to this story and validating behavior:
  - File: tests/rules/valid-req-reference.test.ts
  - Header:
    /****
     * Tests for: docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
     * @story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
     * @req REQ-DEEP-PARSE - Verify valid-req-reference rule enforces existing requirement content
     */
  - Uses RuleTester to run the 'valid-req-reference' rule with multiple cases:
    - VALID cases:
      1) name: "[REQ-DEEP-PARSE] valid requirement reference existing in story file"
         code:
           // @story docs/stories/001.0-DEV-PLUGIN-SETUP.story.md
           // @req REQ-PLUGIN-STRUCTURE
         → Confirms rule accepts a reference to a real requirement in a real story file.
      2) name: "[REQ-DEEP-BULLET] valid bullet list requirement existing in bullet story fixture"
         code:
           // @story tests/fixtures/story_bullet.md
           // @req REQ-BULLET-LIST
         → Confirms bullet-list style requirements are parsed correctly via regex.
    - INVALID cases:
      1) "[REQ-DEEP-MATCH] missing requirement in story file":
         - Story: docs/stories/001.0-DEV-PLUGIN-SETUP.story.md
         - @req REQ-NON-EXISTENT
         - Expects error: messageId "reqMissing" with data { reqId: "REQ-NON-EXISTENT", storyPath: "docs/stories/001.0-DEV-PLUGIN-SETUP.story.md" }.
      2) "[REQ-DEEP-PARSE] disallow path traversal in story path":
         - Story: ../docs/stories/001.0-DEV-PLUGIN-SETUP.story.md
         - Expects error: messageId "invalidPath" with storyPath set to the unsafe path.
      3) "[REQ-DEEP-PARSE] disallow absolute path in story path":
         - Story: /absolute/path/docs/stories/001.0-DEV-PLUGIN-SETUP.story.md
         - Expects error: messageId "invalidPath".
      4) "[REQ-DEEP-BULLET] missing bullet list requirement in bullet story fixture":
         - Story: tests/fixtures/story_bullet.md
         - @req REQ-MISSING-BULLET
         - Expects error: messageId "reqMissing" with data { reqId: "REQ-MISSING-BULLET", storyPath: "tests/fixtures/story_bullet.md" }.,Story fixtures and real requirement content used by the rule/tests:
  - docs/stories/001.0-DEV-PLUGIN-SETUP.story.md defines:
    - **REQ-PLUGIN-STRUCTURE**: ESLint plugin follows standard Node.js module structure
    (and other REQ-* IDs), ensuring positive match for the first valid test.
  - tests/fixtures/story_bullet.md:
    ## Requirements
    - REQ-BULLET-LIST - a requirement in bullet list format
    - REQ-ANOTHER - another requirement
    → Confirms bullet-list format is supported by simple REQ- regex.
  - docs/stories/010.0-DEV-DEEP-VALIDATION.story.md exists and documents all REQ-DEEP-* requirements.,Rule documentation exists and matches story intent:
  - File: docs/rules/valid-req-reference.md
  - Includes traceability header:
    @story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
    @req REQ-DEEP-PARSE - Parse story files to extract requirement identifiers
    @req REQ-DEEP-MATCH - Validate `@req` references against story file content
    @req REQ-DEEP-PATH - Protect against path traversal in story paths
  - Describes behavior in line with acceptance criteria:
    - Verifies the referenced story file exists and is within the project directory.
    - Parses the story file to extract requirement IDs (e.g., REQ-XXX-YYY).
    - Ensures each @req annotation matches an extracted requirement ID.
    - Reports `invalidPath` on '..' or absolute paths.
    - Reports `reqMissing` when requirement is not found.,Plugin-level documentation mentions the rule and its purpose:
  - README.md, "Available Rules" section:
    - `traceability/valid-req-reference` Validates that `@req` references point to existing requirement IDs. ([Documentation](docs/rules/valid-req-reference.md)),Tests (including this rule) have been executed successfully:
  - Project-wide test runs (from earlier steps):
    - Command: npm test -- --runInBand --verbose
      → Executes Jest in CI, in-band, verbose; no failures reported in provided output.
    - Specific rule test run:
      - Command: npm test -- --runInBand --verbose tests/rules/valid-req-reference.test.ts
      - Output:
        > eslint-plugin-traceability@1.0.5 test
        > jest --ci --bail --runInBand --verbose tests/rules/valid-req-reference.test.ts
      → Command completed without error output, indicating tests for this rule pass.</evidence>
  <notes>Story 010.0-DEV-DEEP-VALIDATION is fully implemented via the `valid-req-reference` ESLint rule and its tests/docs.

Mapping to acceptance criteria:
- Core Functionality: Implemented by `validateReqLine`, `handleAnnotationLine`, `handleComment`, and `programListener` in src/rules/valid-req-reference.ts. The rule walks all comments, tracks the current @story path, reads the corresponding story file, extracts all REQ-*-style IDs, and reports `reqMissing` when an @req refers to an ID not present in that file.
- Quality Standards: The rule uses a generic `REQ-[A-Z0-9-]+` regex applied over the full file content, so it handles requirements appearing in various formats and sections (plain lists, bullet lists, and other markdown structures). This is verified by tests against both a standard story file (001.0) and a bullet-list fixture (story_bullet.md).
- Integration: The rule is exported by the plugin (src/index.ts), included in RULE_NAMES, and enabled in both `recommended` and `strict` configs as `traceability/valid-req-reference`. It coexists with existing annotation and file-validation rules and participates in the overall plugin rule set.
- User Experience: Clear, specific error messages are defined: `reqMissing: "Requirement '{{reqId}}' not found in '{{storyPath}}'"` and `invalidPath: "Invalid story path '{{storyPath}}'"`, which are asserted in the Jest tests.
- Error Handling: File reads are wrapped in try/catch; on any read/parse error the code stores an empty requirement set instead of throwing, ensuring ESLint does not crash even for missing or malformed story files. Combined with the separate `valid-story-reference` rule (for file existence) this provides graceful handling while still flagging missing requirements.
- Documentation: The rule has a dedicated documentation file (docs/rules/valid-req-reference.md) linked from README.md. It references this story, enumerates the deep-validation behavior, and gives correct and incorrect examples that align with the implemented functionality.

The REQ-DEEP-* requirements are also addressed:
- REQ-DEEP-PARSE: Story file content is read and scanned with a regex to extract all REQ-IDs.
- REQ-DEEP-MATCH: Each @req ID is checked for membership in the extracted set; mismatches produce `reqMissing`.
- REQ-DEEP-FORMAT / REQ-DEEP-SECTION: The REQ- regex operates across the entire markdown content, so different sections and markdown list formats are supported as long as they contain `REQ-...` identifiers (demonstrated for standard and bullet-list formats in tests).
- REQ-DEEP-CACHE: A per-Program Map caches the parsed requirement IDs per story file to avoid re-reading and re-parsing the same file within one lint run.
- REQ-DEEP-ERROR: Specific, parameterized error messages (`reqMissing`, `invalidPath`) are provided and validated by tests.

Given the implemented rule, passing targeted tests, and up-to-date documentation, all acceptance criteria for this story are satisfied.</notes>
</traceability>