<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/010.0-DEV-DEEP-VALIDATION.story.md</specification>
  <status>PASSED</status>
  <last_validated>2025-11-20T20:58:46.678Z</last_validated>
  <last_modified>2025-11-19T04:17:32.853Z</last_modified>
  <evidence>1) Story file existence and requirements:
- docs/stories/010.0-DEV-DEEP-VALIDATION.story.md exists and defines:
  - REQ-DEEP-PARSE, REQ-DEEP-MATCH, REQ-DEEP-FORMAT, REQ-DEEP-SECTION, REQ-DEEP-CACHE, REQ-DEEP-ERROR (lines 39–44).

2) Implementing rule: src/rules/valid-req-reference.ts
- File header:
  - "Rule to validate @req annotation references refer to existing requirements in story files"
  - @story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
  - @req REQ-DEEP-PARSE, REQ-DEEP-MATCH, REQ-DEEP-CACHE, REQ-DEEP-PATH

- Deep parsing and matching (REQ-DEEP-PARSE, REQ-DEEP-MATCH, REQ-DEEP-FORMAT, REQ-DEEP-SECTION):
  - function validateReqLine(opts):
    - Extracts reqId from an @req line: `const parts = line.split(/\s+/); const reqId = parts[1];`.
    - Requires both reqId and storyPath to proceed.
    - On first use for a given story file, reads file content: `fs.readFileSync(resolvedStoryPath, "utf8")` inside try/catch.
    - Parses content with `const regex = /REQ-[A-Z0-9-]+/g;` and collects all matches into `Set<string>`.
    - This regex scans entire markdown, so it supports inline requirements, bullet lists, numbered lists, and acceptance-criteria checkboxes as long as they contain REQ- tokens (REQ-DEEP-FORMAT and REQ-DEEP-SECTION).
    - Checks `if (!reqSet.has(reqId))` and reports a missing requirement via `context.report` with `messageId: "reqMissing"` and data `{ reqId, storyPath }` (REQ-DEEP-MATCH, REQ-DEEP-ERROR).

- Caching and performance (REQ-DEEP-CACHE):
  - validateReqLine receives a shared `reqCache: Map<string, Set<string>>`.
  - On cache miss (`!reqCache.has(resolvedStoryPath)`), it parses file and stores `Set` in the map.
  - On subsequent validations for the same story path, uses cached Set without re-reading the file.
  - reqCache is created once per Program in programListener and reused across all comments, satisfying the caching requirement.

- Path and security validation (part of Quality Standards and Error Handling):
  - Before reading files, validateReqLine checks:
    - `if (storyPath.includes("..") || path.isAbsolute(storyPath))` → reports `invalidPath` with data `{ storyPath }`.
    - Resolves absolute path: `const resolvedStoryPath = path.resolve(cwd, storyPath)`.
    - Ensures the resolved path is within cwd: if it doesn’t start with `cwd + path.sep` (and isn’t exactly cwd), reports `invalidPath`.

- Error handling (REQ-DEEP-ERROR / Error Handling acceptance criterion):
  - File read/parse is wrapped in `try { ... } catch { reqCache.set(resolvedStoryPath, new Set()); }`.
  - On unreadable/missing/malformed story file, it caches an empty Set, resulting in a `reqMissing` error for any referenced reqId rather than throwing.
  - User-facing messages defined in meta.messages:
    - `reqMissing: "Requirement '{{reqId}}' not found in '{{storyPath}}'"`.
    - `invalidPath: "Invalid story path '{{storyPath}}'"`.

- Integration with annotation parsing:
  - extractStoryPath(comment): scans comment.value lines, strips `*` prefixes, finds `@story` lines, and returns the story path token (REQ-DEEP-PARSE).
  - handleAnnotationLine({ line, comment, context, cwd, reqCache, storyPath }):
    - If line starts with "@story": updates storyPath via extractStoryPath.
    - If line starts with "@req": delegates to validateReqLine to perform deep validation.
  - handleComment({ comment, context, cwd, reqCache, rawStoryPath }):
    - Iterates comment lines, normalizes them, and passes through handleAnnotationLine, maintaining the current storyPath.
  - programListener(context):
    - Creates shared `reqCache = new Map<string, Set<string>>()` and `cwd = process.cwd()`.
    - Returns Program visitor that collects `sourceCode.getAllComments()` and runs handleComment on each, threading `rawStoryPath` across comments.
  - Exported default rule object:
    - meta: describes behavior and messages.
    - create(context): returns `{ Program: programListener(context) }`.
  - This shows the deep validation is fully integrated into the existing annotation parsing and ESLint rule structure.

3) Plugin-level integration: src/index.ts
- RULE_NAMES includes "valid-req-reference".
- Dynamic loader `require(`./rules/${name}`)` loads the rule module.
- Both `configs.recommended` and `configs.strict` enable the rule:
  - `"traceability/valid-req-reference": "error"`.
- Confirms this deep validation is part of the normal plugin configuration (Integration acceptance criterion).

4) Tests specifically tied to this story: tests/rules/valid-req-reference.test.ts
- File header:
  - "Tests for: docs/stories/010.0-DEV-DEEP-VALIDATION.story.md".
  - `@story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md`.
  - `@req REQ-DEEP-PARSE - Verify valid-req-reference rule enforces existing requirement content`.
- Uses ESLint RuleTester with rule imported from `../../src/rules/valid-req-reference`.
- describe block explicitly references story: `"Valid Req Reference Rule (Story 010.0-DEV-DEEP-VALIDATION)"`.
- Valid cases:
  - "[REQ-DEEP-PARSE] valid requirement reference existing in story file":
    - Code: `// @story docs/stories/001.0-DEV-PLUGIN-SETUP.story.md` and `// @req REQ-PLUGIN-STRUCTURE`.
    - REQ-PLUGIN-STRUCTURE is defined in docs/stories/001.0-DEV-PLUGIN-SETUP.story.md under Requirements.
  - "[REQ-DEEP-BULLET] valid bullet list requirement existing in bullet story fixture":
    - Code: `// @story tests/fixtures/story_bullet.md` and `// @req REQ-BULLET-LIST`.
    - tests/fixtures/story_bullet.md has bullet list requirements including `REQ-BULLET-LIST`.
- Invalid cases:
  - "[REQ-DEEP-MATCH] missing requirement in story file":
    - Uses `@req REQ-NON-EXISTENT` with a valid story file; expects error with `messageId: "reqMissing"` and correct data. Validates missing-requirement error behavior.
  - "[REQ-DEEP-PARSE] disallow path traversal in story path":
    - Uses story path with `..`; expects `invalidPath` error.
  - "[REQ-DEEP-PARSE] disallow absolute path in story path":
    - Uses absolute story path; expects `invalidPath` error.
  - "[REQ-DEEP-BULLET] missing bullet list requirement in bullet story fixture":
    - Uses bullet-list fixture but a non-existent REQ; expects `reqMissing`.
- These tests collectively verify:
  - Deep matching against story content.
  - Support for bullet-list formats and arbitrary sections.
  - Clear error messaging for both missing requirements and invalid paths.

5) Fixtures showing multiple formats: tests/fixtures/story_bullet.md
- Markdown structure:
  - `## Requirements` section with bullet items:
    - `- REQ-BULLET-LIST - a requirement in bullet list format`.
    - `- REQ-ANOTHER - another requirement`.
- Since the rule’s regex is `REQ-[A-Z0-9-]+` across full content, it supports this bullet-list format as required in REQ-DEEP-FORMAT and REQ-DEEP-SECTION.

6) User-facing documentation for this rule: docs/rules/valid-req-reference.md
- Tied to the story and requirements:
  - `@story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md`.
  - @req REQ-DEEP-PARSE, REQ-DEEP-MATCH, REQ-DEEP-PATH.
- Describes behavior:
  - Validates that `@req` annotations reference existing requirements in story files.
  - Protects against invalid paths.
  - Lists behaviors:
    - Verifies referenced story file exists and is within project directory.
    - Parses story file to extract requirement IDs (REQ-XXX-YYY pattern).
    - Ensures each @req matches an extracted requirement ID.
    - Reports invalidPath for `..` or absolute paths.
    - Reports reqMissing when a requirement ID is not found.
- Provides concrete examples for correct usage, missing requirement, path traversal, and absolute path cases.
- This satisfies the Documentation acceptance criterion with clear examples of supported formats and error cases.

7) Test execution evidence
- package.json defines: `"test": "jest --ci --bail"`.
- Command executed: `npm test -- --ci --no-watch --runInBand --verbose`.
- Output shows Jest running with CI/bail/verbose flags and prints various console.debug logs from other rules, but no test failures or error summary.
- Given `--bail`, any failure in tests/rules/valid-req-reference.test.ts would abort the run with a failure report; the absence of such output indicates all tests, including those for this story, pass successfully.</evidence>
  <notes>Story 010.0-DEV-DEEP-VALIDATION (Requirement Content Validation) is fully implemented. The `valid-req-reference` rule performs deep validation by reading referenced story files, extracting all requirement IDs using a REQ-... pattern, caching results to avoid repeated parsing, and ensuring each `@req` annotation refers to an existing requirement identifier in the file. It also defends against path traversal and absolute paths, provides clear, parameterized error messages for both missing requirements and invalid paths, and gracefully handles unreadable/malformed story files by catching errors and reporting missing requirements instead of throwing. The rule is integrated into the plugin’s recommended and strict configs and works atop existing annotation parsing. Dedicated tests explicitly linked to this story validate positive and negative cases, including bullet-list formats and path errors. User-facing documentation in docs/rules/valid-req-reference.md explains the behavior and includes examples. The Jest test suite (npm test with CI flags) completes without failures, confirming that all tests for this story pass. All acceptance criteria and listed requirements (REQ-DEEP-PARSE, REQ-DEEP-MATCH, REQ-DEEP-FORMAT, REQ-DEEP-SECTION, REQ-DEEP-CACHE, REQ-DEEP-ERROR) are satisfied.</notes>
</traceability>