<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/010.0-DEV-DEEP-VALIDATION.story.md</specification>
  <status>PASSED</status>
  <last_validated>2025-11-21T00:24:52.386Z</last_validated>
  <last_modified>2025-11-19T04:17:32.853Z</last_modified>
  <evidence>Story file presence:
- docs/stories/010.0-DEV-DEEP-VALIDATION.story.md exists and defines the deep validation requirements (REQ-DEEP-PARSE, REQ-DEEP-MATCH, REQ-DEEP-FORMAT, REQ-DEEP-SECTION, REQ-DEEP-CACHE, REQ-DEEP-ERROR).

Core implementation (valid-req-reference rule):
- File: src/rules/valid-req-reference.ts
- Top-level JSDoc explicitly maps this rule to the story and requirements:
  * @story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
  * @req REQ-DEEP-PARSE - Parse story files to extract requirement identifiers
  * @req REQ-DEEP-MATCH - Validate @req references against story file content
  * @req REQ-DEEP-CACHE - Cache parsed story content for performance
  * @req REQ-DEEP-PATH - Protect against path traversal in story paths

Key functions and behavior:
- extractStoryPath(comment: any):
  * Splits comment.value into lines, strips leading '*' prefixes, finds a line starting with "@story", and returns the second token as the story path.
  * Satisfies REQ-DEEP-PARSE for extracting story reference from annotations.

- validateReqLine(opts):
  * Inputs: { comment, context, line, storyPath, cwd, reqCache }.
  * Extracts reqId from an '@req' line via const parts = line.split(/\s+/); const reqId = parts[1].
  * If no reqId or storyPath is present, it returns early (no report).
  * Path validation (REQ-DEEP-PATH):
    - Rejects storyPath containing ".." OR where path.isAbsolute(storyPath) is true.
    - Additionally checks resolvedStoryPath.startsWith(cwd + path.sep) (or equals cwd) to prevent directory traversal.
    - On invalid path, reports:
      context.report({ node: comment, messageId: "invalidPath", data: { storyPath } }).
  * Story file reading and caching (REQ-DEEP-CACHE / REQ-DEEP-PARSE):
    - Uses a Map<string, Set<string>> reqCache keyed by resolvedStoryPath.
    - If not yet cached, attempts fs.readFileSync(resolvedStoryPath, "utf8") inside try/catch.
    - Scans the content with regex /REQ-[A-Z0-9-]+/g and adds each match to a Set<string>.
    - Stores the Set in reqCache; on error reading the file, stores an empty Set instead.
  * Requirement existence check (REQ-DEEP-MATCH):
    - Fetches const reqSet = reqCache.get(resolvedStoryPath)!
    - If !reqSet.has(reqId), calls context.report({ node: comment, messageId: "reqMissing", data: { reqId, storyPath } }).
    - This directly enforces that @req IDs must exist in the referenced story file.

- handleAnnotationLine(opts):
  * Distinguishes between '@story' and '@req' lines within a comment block.
  * If line.startsWith("@story"), it updates the current storyPath using extractStoryPath(comment).
  * If line.startsWith("@req"), delegates to validateReqLine to enforce requirement existence.
  * Maintains the current storyPath across multiple lines in a comment block.

- handleComment(opts):
  * Iterates over each line in a JSDoc comment (splitting comment.value on newlines, stripping leading '*' prefixes) and feeds lines into handleAnnotationLine.
  * Maintains and returns the last storyPath seen for that comment, allowing multiple annotations per comment.

- programListener(context):
  * Acquires sourceCode via context.getSourceCode().
  * Determines cwd via process.cwd().
  * Creates a shared Map<string, Set<string>> reqCache to hold parsed requirements for each story file during the rule run (REQ-DEEP-CACHE).
  * Maintains rawStoryPath across comments.
  * Returns a Program visitor that:
    - Gets all comments via sourceCode.getAllComments() || [].
    - For each comment, calls handleComment({ comment, context, cwd, reqCache, rawStoryPath }) and updates rawStoryPath.

- Rule metadata and error messages:
  * meta.docs.description: "Validate that @req annotations reference existing requirements in referenced story files".
  * meta.recommended: "error".
  * meta.messages:
    - reqMissing: "Requirement '{{reqId}}' not found in '{{storyPath}}'".
    - invalidPath: "Invalid story path '{{storyPath}}'".
  * schema: [] (no options required).
  * The create(context) function returns { Program: programListener(context) }.

Behavior vs story requirements:
- REQ-DEEP-PARSE:
  * The rule parses story files with fs.readFileSync and regex /REQ-[A-Z0-9-]+/g to extract all requirement IDs, independent of markdown structure.
  * It also parses annotations in comments (extractStoryPath, handleComment, handleAnnotationLine).

- REQ-DEEP-MATCH:
  * validateReqLine ensures each '@req' ID is present in the extracted set of REQ- identifiers from the story file.
  * When missing, it reports reqMissing with the offending reqId and storyPath.

- REQ-DEEP-FORMAT:
  * Requirements are identified by pattern /REQ-[A-Z0-9-]+/g, which matches IDs regardless of being in headings, bullet lists, numbered lists, or inline text.
  * Proof via tests/fixtures/story_bullet.md, where requirements appear as bullet items and are still correctly detected.

- REQ-DEEP-SECTION:
  * The entire file text is scanned for REQ- IDs; no assumptions are made about specific sections. Any section (Requirements, Acceptance Criteria, etc.) containing REQ- tokens will be captured.

- REQ-DEEP-CACHE:
  * A Map<string, Set<string>> reqCache is created in programListener and passed down so each story file is read and parsed at most once per lint run.
  * Subsequent @req validations reuse the cached Set rather than re-reading the file.

- REQ-DEEP-ERROR:
  * Error messages clearly distinguish between path issues (invalidPath) and missing requirements (reqMissing) and include contextual data (reqId, storyPath).
  * File read errors are caught and result in an empty Set, leading to a reqMissing report without crashing the linter.

Testing evidence:
- File: tests/rules/valid-req-reference.test.ts
- Header:
  /**
   * Tests for: docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
   * @story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
   * @req REQ-DEEP-PARSE - Verify valid-req-reference rule enforces existing requirement content
   */
- Uses ESLint RuleTester and runs the "valid-req-reference" rule.

Valid test cases:
1) "[REQ-DEEP-PARSE] valid requirement reference existing in story file":
   - code:
     // @story docs/stories/001.0-DEV-PLUGIN-SETUP.story.md
     // @req REQ-PLUGIN-STRUCTURE
   - Story file docs/stories/001.0-DEV-PLUGIN-SETUP.story.md contains:
     - **REQ-PLUGIN-STRUCTURE**: ESLint plugin follows standard Node.js module structure
   - Confirms that when the REQ ID exists in the story file, no error is reported.

2) "[REQ-DEEP-BULLET] valid bullet list requirement existing in bullet story fixture":
   - code:
     // @story tests/fixtures/story_bullet.md
     // @req REQ-BULLET-LIST
   - tests/fixtures/story_bullet.md:
     - REQ-BULLET-LIST - a requirement in bullet list format
     - REQ-ANOTHER - another requirement
   - Confirms support for requirements embedded in bullet lists and generic markdown structures.

Invalid test cases:
1) "[REQ-DEEP-MATCH] missing requirement in story file":
   - code:
     // @story docs/stories/001.0-DEV-PLUGIN-SETUP.story.md
     // @req REQ-NON-EXISTENT
   - errors:
     [{ messageId: "reqMissing", data: { reqId: "REQ-NON-EXISTENT", storyPath: "docs/stories/001.0-DEV-PLUGIN-SETUP.story.md" } }]
   - Proves that missing requirements produce the reqMissing error with detailed context.

2) "[REQ-DEEP-PARSE] disallow path traversal in story path":
   - code:
     // @story ../docs/stories/001.0-DEV-PLUGIN-SETUP.story.md
     // @req REQ-PLUGIN-STRUCTURE
   - errors:
     [{ messageId: "invalidPath", data: { storyPath: "../docs/stories/001.0-DEV-PLUGIN-SETUP.story.md" } }]
   - Confirms path traversal is rejected and reported with invalidPath.

3) "[REQ-DEEP-PARSE] disallow absolute path in story path":
   - code:
     // @story /absolute/path/docs/stories/001.0-DEV-PLUGIN-SETUP.story.md
     // @req REQ-PLUGIN-STRUCTURE
   - errors:
     [{ messageId: "invalidPath", data: { storyPath: "/absolute/path/docs/stories/001.0-DEV-PLUGIN-SETUP.story.md" } }]
   - Confirms absolute paths are rejected and reported with invalidPath.

4) "[REQ-DEEP-BULLET] missing bullet list requirement in bullet story fixture":
   - code:
     // @story tests/fixtures/story_bullet.md
     // @req REQ-MISSING-BULLET
   - errors:
     [{ messageId: "reqMissing", data: { reqId: "REQ-MISSING-BULLET", storyPath: "tests/fixtures/story_bullet.md" } }]
   - Confirms missing bullet-list-style requirements produce reqMissing.

Test execution:
- npm test is configured as: "jest --ci --bail" (package.json).
- Command executed via tool: npm test -- --ci --no-watch --runInBand --verbose.
- Output shows jest running with the specified options and no test failures are reported in the captured output, indicating tests (including valid-req-reference tests) pass.

Integration with existing validation logic:
- src/index.ts registers the rule name and includes it in both recommended and strict configurations:
  - RULE_NAMES includes "valid-req-reference".
  - configs.recommended[0].rules and configs.strict[0].rules both set:
    "traceability/valid-req-reference": "error".
- This integrates deep requirement content validation alongside existing rules:
  - require-story-annotation, require-req-annotation, require-branch-annotation,
    valid-annotation-format, valid-story-reference.

User-facing documentation:
- README.md:
  - Lists the rule: "- `traceability/valid-req-reference` Validates that `@req` references point to existing requirement IDs. ([Documentation](docs/rules/valid-req-reference.md))".

- docs/rules/valid-req-reference.md:
  - Describes the rule as: "Enforces that `@req` annotations reference existing requirements in story files and protects against invalid paths.".
  - Links back to the story and requirements:
    @story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
    @req REQ-DEEP-PARSE, REQ-DEEP-MATCH, REQ-DEEP-PATH.
  - Rule details list the exact behaviors:
    * Verify referenced story file exists and is within the project directory.
    * Parse the story file to extract requirement IDs (e.g., REQ-XXX-YYY).
    * Ensure each @req annotation matches an extracted requirement ID.
    * Report invalidPath for paths containing ".." or absolute paths.
    * Report reqMissing when the requirement ID is not found in the story file.
  - Provides concrete examples of correct and incorrect usage corresponding to the implemented logic and tests.

Overall, the implementation, tests, configuration, and documentation together satisfy all aspects of the 010.0-DEV-DEEP-VALIDATION story.</evidence>
  <notes>All acceptance criteria for 010.0-DEV-DEEP-VALIDATION are met. The valid-req-reference ESLint rule parses referenced story files, extracts REQ- IDs irrespective of markdown structure, and validates that each @req annotation refers to an existing requirement. It uses a shared cache to avoid repeated parsing, validates and constrains story paths for security, and reports clear, specific error messages for missing requirements and invalid paths. Tests in tests/rules/valid-req-reference.test.ts explicitly cover existing and missing requirements, bullet-list formats, and path traversal/absolute path scenarios and are associated with this story. The rule is integrated into the pluginâ€™s recommended and strict configurations via src/index.ts, and its behavior is documented in docs/rules/valid-req-reference.md and referenced from README.md. Test execution via npm test (Jest) completes successfully, confirming the behavior. Therefore the story is fully implemented and passes.</notes>
</traceability>