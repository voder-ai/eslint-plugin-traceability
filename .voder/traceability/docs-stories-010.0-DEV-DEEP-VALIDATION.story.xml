<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/010.0-DEV-DEEP-VALIDATION.story.md</specification>
  <status>PASSED</status>
  <last_validated>2025-11-21T05:03:41.045Z</last_validated>
  <last_modified>2025-11-19T04:17:32.853Z</last_modified>
  <evidence>Implementation and tests for deep requirement validation are present and passing:

1. Core rule implementation
- File: src/rules/valid-req-reference.ts
- Purpose (per header): "Rule to validate @req annotation references refer to existing requirements in story files"
- Uses fs.readFileSync and a Map-based cache (reqCache) to:
  - Extract story path from JSDoc/line comments (extractStoryPath)
  - For each @req line, resolve and validate the story path, read the story file, and parse requirement IDs with `/REQ-[A-Z0-9-]+/g`
  - Cache requirement IDs per resolved story file path to avoid re-reading for multiple @req lines
  - Report `reqMissing` when a referenced requirement ID is not found in the parsed set
  - Report `invalidPath` for paths containing `..` or absolute paths, and for paths escaping the cwd
- Meta messages:
  - reqMissing: "Requirement '{{reqId}}' not found in '{{storyPath}}'"
  - invalidPath: "Invalid story path '{{storyPath}}'"
- Rule is wired into the plugin export and configs:
  - src/index.ts includes "valid-req-reference" in RULE_NAMES
  - Both `configs.recommended` and `configs.strict` enable `"traceability/valid-req-reference": "error"`

2. Story-specific tests
- File: tests/rules/valid-req-reference.test.ts
- Header explicitly traces to this story:
  - `* Tests for: docs/stories/010.0-DEV-DEEP-VALIDATION.story.md`
  - `* @story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md`
  - `* @req REQ-DEEP-PARSE - Verify valid-req-reference rule enforces existing requirement content`
- Uses ESLint RuleTester to exercise the rule under the name "valid-req-reference".
- Valid cases demonstrate successful deep validation:
  - References a real story file and existing requirement ID:
    - `// @story docs/stories/001.0-DEV-PLUGIN-SETUP.story.md`
    - `// @req REQ-PLUGIN-STRUCTURE`
  - References a bullet-list style fixture:
    - `// @story tests/fixtures/story_bullet.md`
    - `// @req REQ-BULLET-LIST`
- Invalid cases verify error reporting and path validation:
  - Missing requirement in an existing story file:
    - Expects `messageId: "reqMissing"` with `reqId: "REQ-NON-EXISTENT"` and correct storyPath
  - Path traversal and absolute paths:
    - Expects `messageId: "invalidPath"` for `../docs/...` and `/absolute/path/...`
  - Bullet-list requirement missing in fixture:
    - Expects `messageId: "reqMissing"` against `tests/fixtures/story_bullet.md`

3. Story file / requirement formats
- Story under test: docs/stories/001.0-DEV-PLUGIN-SETUP.story.md (referenced by tests) contains requirement IDs such as `REQ-PLUGIN-STRUCTURE` in markdown prose, which are picked up by the generic regex.
- Bullet-list fixture: tests/fixtures/story_bullet.md
  - Contains requirements in bullet format:
    - `- REQ-BULLET-LIST - a requirement in bullet list format`
    - `- REQ-ANOTHER - another requirement`
  - These IDs are correctly recognized by the regex-based parser used in valid-req-reference.ts.
- Because parsing is done with a global regex over the entire markdown file, requirements are discoverable regardless of section (Requirements, Acceptance Criteria, etc.) or list style (plain text, bullets, numbered lists) so long as they contain a `REQ-...` token.

4. Error handling behavior
- In src/rules/valid-req-reference.ts, the file-read and parsing logic is wrapped in a try/catch:
  - On any fs error (missing file, permission issue, malformed content), the rule sets an empty Set for that story path in the cache and continues, avoiding crashes.
  - Later, the absence of the ID in the set triggers a `reqMissing` report if a requirement is referenced.
- Path security and project boundary checks are implemented before reading:
  - Rejects story paths containing `".."` or absolute paths via `path.isAbsolute(storyPath)` and a startsWith(cwd + path.sep) check.
  - These conditions report `invalidPath` instead of throwing.

5. Documentation
- File: docs/rules/valid-req-reference.md
- Explicitly annotated with this story and relevant requirements:
  - `@story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md`
  - `@req REQ-DEEP-PARSE - Parse story files to extract requirement identifiers`
  - `@req REQ-DEEP-MATCH - Validate @req references against story file content`
  - `@req REQ-DEEP-PATH - Protect against path traversal in story paths`
- Describes behavior consistent with the story:
  - Verifies referenced story file exists and is within project directory (in conjunction with the file-validation rule)
  - Parses story file to extract requirement IDs of the form `REQ-XXX-YYY`
  - Ensures each `@req` matches an extracted requirement ID
  - Documents `invalidPath` and `reqMissing` errors with code examples (correct, missing requirement, path traversal, absolute path).
- README.md references the rule:
  - Line 56: `- traceability/valid-req-reference Validates that @req references point to existing requirement IDs. (Documentation link)`

6. Test execution
- Command run: `npm test -- --verbose`
- Underlying runner: `jest --ci --bail --verbose`
- Output shows tests executing (including rules/valid-req-reference via Jest’s normal discovery) with no reported failures or error summary; the command returned without an error indication in the tool output, consistent with a passing test suite.

7. Mapping to story acceptance criteria
- Core Functionality: Implemented by valid-req-reference.ts and verified by valid and invalid cases in tests/rules/valid-req-reference.test.ts. @req annotations are checked against actual requirement IDs parsed from the target story files.
- Quality Standards: Regex-based parsing of `REQ-...` IDs over entire markdown content, plus tests using both standard story files and a bullet-list fixture, demonstrate handling of multiple formats and story structures.
- Integration: Rule is exported via src/index.ts and enabled in both recommended and strict configs; it operates alongside existing annotation and file validation rules, completing the deep validation layer described by story 010.0.
- User Experience: Clear, specific error messages (`reqMissing`, `invalidPath`) are defined in meta.messages and asserted in tests; messages include the missing requirement ID and story path.
- Error Handling: File IO is wrapped in try/catch to prevent crashes on missing or malformed files; invalid paths are explicitly validated and reported; missing @story/@req data short-circuits safely.
- Documentation: docs/rules/valid-req-reference.md documents the behavior, error conditions, and usage examples, and is linked from README.md.

Taken together, the implementation, tests, and documentation provide concrete evidence that all acceptance criteria in docs/stories/010.0-DEV-DEEP-VALIDATION.story.md are satisfied.</evidence>
  <notes>The `valid-req-reference` ESLint rule, its associated tests, and its documentation collectively implement the deep requirement content validation described in story 010.0-DEV-DEEP-VALIDATION. The rule parses story files to discover requirement IDs, caches them, validates @req annotations against them, enforces safe story paths, reports clear errors, and is integrated into the plugin’s recommended/strict configurations. Tests specifically tied to this story verify successful matches, missing requirements, path traversal, and bullet-list formats. Documentation in docs/rules/valid-req-reference.md, referenced from README.md, describes this behavior and provides examples. No unmet acceptance criteria or missing required functionality were found for this story.</notes>
</traceability>