<?xml version="1.0" encoding="UTF-8"?>
<traceability>
  <specification>docs/stories/010.0-DEV-DEEP-VALIDATION.story.md</specification>
  <status>PASSED</status>
  <last_validated>2025-11-21T01:24:00.308Z</last_validated>
  <last_modified>2025-11-19T04:17:32.853Z</last_modified>
  <evidence>1) Story-linked implementation:
- File: src/rules/valid-req-reference.ts
  - Top-level JSDoc explicitly links this rule to the story and its requirements:
    - @story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
    - @req REQ-DEEP-PARSE - Parse story files to extract requirement identifiers
    - @req REQ-DEEP-MATCH - Validate @req references against story file content
    - @req REQ-DEEP-CACHE - Cache parsed story content for performance
    - @req REQ-DEEP-PATH - Protect against path traversal in story paths
  - Core helpers:
    - extractStoryPath(comment):
      - Splits comment.value into lines, trims, strips leading '*', finds line starting with '@story', and returns the path token.
      - Implements annotation parsing needed for deep validation (REQ-DEEP-PARSE) and integrates with existing annotation parsing logic.
    - validateReqLine({ comment, context, line, storyPath, cwd, reqCache }):
      - Extracts reqId from '@req' line via line.split(/\s+/).
      - If reqId or storyPath are missing, returns early (no crash on malformed annotations).
      - Security and path validation (REQ-DEEP-PATH):
        - Rejects storyPath with '..' or absolute paths (path.isAbsolute).
        - Resolves storyPath with path.resolve(cwd, storyPath) and ensures the resolved path stays under cwd.
        - On invalid paths, reports:
          - messageId: "invalidPath"
          - data: { storyPath }
      - File parsing and caching (REQ-DEEP-PARSE, REQ-DEEP-CACHE):
        - Uses a Map<string, Set<string>> (reqCache) keyed by resolvedStoryPath.
        - If not cached, attempts fs.readFileSync(resolvedStoryPath, "utf8") and scans content with regex /REQ-[A-Z0-9-]+/g, adding each match to a Set.
        - Stores the Set in reqCache; if fs.readFileSync throws (missing or unreadable file), it catches and stores an empty Set instead (graceful error handling without throwing in the rule).
      - Requirement existence check (REQ-DEEP-MATCH, REQ-DEEP-ERROR):
        - After loading reqSet from the cache, if !reqSet.has(reqId), calls context.report with:
          - messageId: "reqMissing"
          - data: { reqId, storyPath }
        - This ties each @req to actual requirement content in the target story file.
    - handleAnnotationLine({ line, comment, context, cwd, reqCache, storyPath }):
      - For '@story' lines, calls extractStoryPath and updates storyPath.
      - For '@req' lines, delegates to validateReqLine.
      - Provides the integration point between annotation parsing and deep requirement validation (Integration acceptance criterion).
    - handleComment({ comment, context, cwd, reqCache, rawStoryPath }):
      - Iterates comment.value line-by-line, normalizing each line and feeding it into handleAnnotationLine.
      - Maintains current storyPath across lines within a comment block, enabling scenarios where @story precedes @req.
    - programListener(context):
      - Obtains sourceCode via context.getSourceCode().
      - Initializes cwd = process.cwd() and a shared reqCache Map for the entire file (REQ-DEEP-CACHE).
      - Returns a Program visitor that:
        - Gets all comments via sourceCode.getAllComments().
        - For each comment, calls handleComment with the shared cache and cwd.
      - This ensures only necessary story files are parsed and that repeated validations reuse cached data.
  - Exported rule:
    - meta:
      - type: "problem"
      - docs.description: "Validate that @req annotations reference existing requirements in referenced story files"
      - recommended: "error"
      - messages:
        - reqMissing: "Requirement '{{reqId}}' not found in '{{storyPath}}'"
        - invalidPath: "Invalid story path '{{storyPath}}'"
      - schema: [] (no options required for core behavior)
    - create(context): returns { Program: programListener(context) }.
    - Error messages are clear and specific, satisfying User Experience and REQ-DEEP-ERROR.

2) Plugin integration:
- File: src/index.ts
  - RULE_NAMES includes "valid-req-reference" among other rules.
  - The dynamic loader requires './rules/valid-req-reference' and attaches it to the rules object.
  - Both "recommended" and "strict" configs enable the rule:
    - "traceability/valid-req-reference": "error"
  - Confirms that deep requirement validation runs as part of normal plugin usage (Integration acceptance criterion).

3) Tests for this story:
- File: tests/rules/valid-req-reference.test.ts
  - Header explicitly ties tests to the story:
    - "Tests for: docs/stories/010.0-DEV-DEEP-VALIDATION.story.md"
    - @story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
    - @req REQ-DEEP-PARSE - Verify valid-req-reference rule enforces existing requirement content.
  - Uses ESLint RuleTester:
    - const ruleTester = new RuleTester({ languageOptions: { parserOptions: { ecmaVersion: 2020 } } } as any);
    - ruleTester.run("valid-req-reference", rule, { valid: [...], invalid: [...] });
  - Valid test cases (Core Functionality + Quality Standards):
    1) name: "[REQ-DEEP-PARSE] valid requirement reference existing in story file"
       - code:
         // @story docs/stories/001.0-DEV-PLUGIN-SETUP.story.md
         // @req REQ-PLUGIN-STRUCTURE
       - docs/stories/001.0-DEV-PLUGIN-SETUP.story.md contains REQ-PLUGIN-STRUCTURE in its requirements section, demonstrating that the rule successfully locates an explicit requirement ID in a real story file.
    2) name: "[REQ-DEEP-BULLET] valid bullet list requirement existing in bullet story fixture"
       - code:
         // @story tests/fixtures/story_bullet.md
         // @req REQ-BULLET-LIST
       - tests/fixtures/story_bullet.md content:
         - REQ-BULLET-LIST - a requirement in bullet list format
         - REQ-ANOTHER - another requirement
       - Confirms bullet-list-formatted requirements are recognized (REQ-DEEP-FORMAT, REQ-DEEP-SECTION, Quality Standards for different structures).
  - Invalid test cases (Error Handling, User Experience, REQ-DEEP-ERROR, REQ-DEEP-PATH):
    1) name: "[REQ-DEEP-MATCH] missing requirement in story file"
       - code:
         // @story docs/stories/001.0-DEV-PLUGIN-SETUP.story.md
         // @req REQ-NON-EXISTENT
       - expected errors:
         [{ messageId: "reqMissing", data: { reqId: "REQ-NON-EXISTENT", storyPath: "docs/stories/001.0-DEV-PLUGIN-SETUP.story.md" } }]
       - Demonstrates that missing requirement IDs correctly trigger reqMissing with clear message data.
    2) name: "[REQ-DEEP-PARSE] disallow path traversal in story path"
       - code:
         // @story ../docs/stories/001.0-DEV-PLUGIN-SETUP.story.md
         // @req REQ-PLUGIN-STRUCTURE
       - expected errors:
         [{ messageId: "invalidPath", data: { storyPath: "../docs/stories/001.0-DEV-PLUGIN-SETUP.story.md" } }]
       - Verifies rejection of path traversal, with explicit invalidPath message (REQ-DEEP-PATH, Error Handling).
    3) name: "[REQ-DEEP-PARSE] disallow absolute path in story path"
       - code:
         // @story /absolute/path/docs/stories/001.0-DEV-PLUGIN-SETUP.story.md
         // @req REQ-PLUGIN-STRUCTURE
       - expected errors:
         [{ messageId: "invalidPath", data: { storyPath: "/absolute/path/docs/stories/001.0-DEV-PLUGIN-SETUP.story.md" } }]
       - Confirms absolute paths are blocked with clear diagnostics.
    4) name: "[REQ-DEEP-BULLET] missing bullet list requirement in bullet story fixture"
       - code:
         // @story tests/fixtures/story_bullet.md
         // @req REQ-MISSING-BULLET
       - expected errors:
         [{ messageId: "reqMissing", data: { reqId: "REQ-MISSING-BULLET", storyPath: "tests/fixtures/story_bullet.md" } }]
       - Validates missing bullet-based requirements are detected with explicit reqMissing messages.

4) Documentation of this behavior:
- File: docs/rules/valid-req-reference.md
  - Links rule to the story and requirements:
    - @story docs/stories/010.0-DEV-DEEP-VALIDATION.story.md
    - @req REQ-DEEP-PARSE - Parse story files to extract requirement identifiers
    - @req REQ-DEEP-MATCH - Validate `@req` references against story file content
    - @req REQ-DEEP-PATH - Protect against path traversal in story paths
  - Explains rule behavior in detail:
    - Verifies referenced story file exists and is within project directory (in collaboration with other rules / validations).
    - Parses story file to extract requirement IDs (REQ-XXX-YYY style).
    - Ensures each `@req` annotation matches an extracted ID.
    - Reports `invalidPath` for paths containing `..` or absolute paths.
    - Reports `reqMissing` when the requirement ID is not found in the story file.
  - Provides concrete examples for correct and incorrect usage, including missing requirement and invalid path cases, fulfilling the Documentation acceptance criterion.

5) Story requirements mapping:
- REQ-DEEP-PARSE: Implemented by:
  - Regex-based extraction in validateReqLine: const regex = /REQ-[A-Z0-9-]+/g; scanning full markdown file contents.
  - Works on any section (Requirements, Acceptance Criteria, bullets, numbered lists) since it is content-based, not section-based.
- REQ-DEEP-MATCH: Implemented by:
  - Comparing the @req ID to the Set of extracted IDs and reporting reqMissing when absent.
  - Covered by tests with existing and non-existent requirement IDs.
- REQ-DEEP-FORMAT: Implemented by:
  - Generic pattern /REQ-[A-Z0-9-]+/ that matches requirement IDs wherever they appear, including bullet points and headings.
  - Explicit bullet-based fixture and tests (story_bullet.md and related tests) demonstrate support beyond one single list style.
- REQ-DEEP-SECTION: Implemented by scanning the entire markdown file without section restrictions, so requirements in different sections (e.g., Requirements, Acceptance Criteria, examples) are all picked up.
- REQ-DEEP-CACHE: Implemented via a per-run Map<string, Set<string>> in programListener, ensuring each story file is parsed at most once per lint run.
- REQ-DEEP-ERROR: Implemented by specific messageIds (reqMissing, invalidPath) and detailed error data; tests assert on these messages and data.

6) Test execution:
- package.json test script: "test": "jest --ci --bail"
- Command executed via tooling: npm test -- --runInBand --verbose
  - Jest ran in CI mode with --bail and --runInBand and verbose output.
  - No failures or stack traces were reported; the command completed successfully, indicating that tests including tests/rules/valid-req-reference.test.ts are passing.

7) Story file presence and linkage:
- File docs/stories/010.0-DEV-DEEP-VALIDATION.story.md exists and is referenced by:
  - src/rules/valid-req-reference.ts (implementation)
  - tests/rules/valid-req-reference.test.ts (tests)
  - docs/rules/valid-req-reference.md (documentation)
- grep search confirms these references are consistent and correctly spelled.
</evidence>
  <notes>The story 010.0-DEV-DEEP-VALIDATION is fully implemented by the valid-req-reference ESLint rule. The rule parses referenced story files to extract requirement IDs, caches them, and validates each @req annotation against those IDs. It includes security-conscious path validation, reports clear and specific errors for missing requirements and invalid paths, and integrates with the plugin’s recommended and strict configurations. Dedicated RuleTester tests cover valid references, missing requirements, bullet-list formats, and invalid paths, while the rule has its own documentation page that describes behavior and provides examples. All tests pass when running the project’s Jest suite. This collectively satisfies the story’s acceptance criteria for core functionality, quality, integration, user experience, error handling, and documentation, so the story is marked as PASSED.</notes>
</traceability>